/*
 * File generated by SourceCombiner.exe using 33 source files.
 */

using PommaLabs.KVLite.Thrower.ExceptionHandlers;
using PommaLabs.KVLite.Thrower.ExceptionHandlers.IO;
using PommaLabs.KVLite.Thrower.ExceptionHandlers.Net;
using PommaLabs.KVLite.Thrower.Reflection;
using PommaLabs.KVLite.Thrower.Validation;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;

//*** SourceCombiner -> original file HttpException.cs ***
namespace PommaLabs.KVLite.Thrower
{
    /// <summary>
    ///   Additional info which will be included into <see cref="HttpException"/>.
    /// </summary>
    [Serializable]
    public struct HttpExceptionInfo
    {
        /// <summary>
        ///   Builds the additional exception info.
        /// </summary>
        /// <param name="errorCode">The application defined error code.</param>
        /// <param name="userMessage">The user message.</param>
        public HttpExceptionInfo(object errorCode = null, string userMessage = null)
        {
            ErrorCode = errorCode ?? HttpException.DefaultErrorCode;
            UserMessage = userMessage ?? HttpException.DefaultUserMessage;
        }

        /// <summary>
        ///   The application defined error code.
        /// </summary>
        public object ErrorCode { get; set; }

        /// <summary>
        ///   An error message which can be shown to user.
        /// </summary>
        public string UserMessage { get; set; }
    }

    /// <summary>
    ///   Represents an exception which contains an error message that should be delivered through
    ///   the HTTP response, using given status code.
    /// </summary>
    [Serializable]
    [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
    public sealed class HttpException : Exception
    {
        /// <summary>
        ///   Builds the exception using given status code.
        /// </summary>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        public HttpException(HttpStatusCode httpStatusCode)
            : this(httpStatusCode, new HttpExceptionInfo())
        {
        }

        /// <summary>
        ///   Builds the exception using given status code.
        /// </summary>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        /// <param name="additionalInfo">Additional exception info.</param>
        public HttpException(HttpStatusCode httpStatusCode, HttpExceptionInfo additionalInfo)
        {
            HttpStatusCode = httpStatusCode;
            ErrorCode = additionalInfo.ErrorCode ?? DefaultErrorCode;
            UserMessage = additionalInfo.UserMessage ?? DefaultUserMessage;
            CustomizeException();
        }

        /// <summary>
        ///   Builds the exception using given status code and message.
        /// </summary>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        /// <param name="message">The exception message.</param>
        public HttpException(HttpStatusCode httpStatusCode, string message)
            : this(httpStatusCode, message, new HttpExceptionInfo())
        {
        }

        /// <summary>
        ///   Builds the exception using given status code, message and error code.
        /// </summary>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        /// <param name="message">The exception message.</param>
        /// <param name="additionalInfo">Additional exception info.</param>
        public HttpException(HttpStatusCode httpStatusCode, string message, HttpExceptionInfo additionalInfo)
            : base(message)
        {
            HttpStatusCode = httpStatusCode;
            ErrorCode = additionalInfo.ErrorCode ?? DefaultErrorCode;
            UserMessage = additionalInfo.UserMessage ?? DefaultUserMessage;
            CustomizeException();
        }

        /// <summary>
        ///   Builds the exception using given status code, message and inner exception.
        /// </summary>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        /// <param name="message">The exception message.</param>
        /// <param name="innerException">The inner exception.</param>
        public HttpException(HttpStatusCode httpStatusCode, string message, Exception innerException)
            : this(httpStatusCode, message, innerException, new HttpExceptionInfo())
        {
        }

        /// <summary>
        ///   Builds the exception using given status code, message, error code and inner exception.
        /// </summary>
        /// <param name="httpStatusCode">The HTTP status code.</param>
        /// <param name="message">The exception message.</param>
        /// <param name="innerException">The inner exception.</param>
        /// <param name="additionalInfo">Additional exception info.</param>
        public HttpException(HttpStatusCode httpStatusCode, string message, Exception innerException, HttpExceptionInfo additionalInfo)
            : base(message, innerException)
        {
            HttpStatusCode = httpStatusCode;
            ErrorCode = additionalInfo.ErrorCode ?? DefaultErrorCode;
            UserMessage = additionalInfo.UserMessage ?? DefaultUserMessage;
            CustomizeException();
        }

        /// <summary>
        ///   The HTTP status code assigned to this exception.
        /// </summary>
        public HttpStatusCode HttpStatusCode { get; }

        /// <summary>
        ///   The application defined error code.
        /// </summary>
        public object ErrorCode { get; }

        /// <summary>
        ///   The default application defined error code, used when none has been specified.
        /// </summary>
        public static object DefaultErrorCode { get; set; } = "unspecified";

        /// <summary>
        ///   An error message which can be shown to the user.
        /// </summary>
        public string UserMessage { get; }

        /// <summary>
        ///   The default user message.
        /// </summary>
        public static string DefaultUserMessage { get; set; } = "unspecified";

        private void CustomizeException()
        {
            HResult = (int) HttpStatusCode;
            Data.Add(nameof(HttpStatusCode), HttpStatusCode.ToString());
            Data.Add(nameof(ErrorCode), ErrorCode?.ToString());
            Data.Add(nameof(UserMessage), UserMessage);
        }
    }
}

//*** SourceCombiner -> original file Raise.cs ***
namespace PommaLabs.KVLite.Thrower
{
    /// <summary>
    ///   New exception handling mechanism, which is more fluent than the old ones.
    /// </summary>
    public static class Raise
    {
        #region Constants

        /// <summary>
        ///   Default implementation options for Raise methods.
        /// </summary>
#if NET35 || NET40
        internal const MethodImplOptions MethodImplOptions = default(System.Runtime.CompilerServices.MethodImplOptions);
#else
        internal const MethodImplOptions MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining;
#endif

        #endregion Constants

        #region System

        /// <summary>
        ///   Handler for <see cref="System.ArgumentException"/>
        /// </summary>
        public static ArgumentExceptionHandler ArgumentException { get; } = new ArgumentExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.ArgumentNullException"/>
        /// </summary>
        public static ArgumentNullExceptionHandler ArgumentNullException { get; } = new ArgumentNullExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.ArgumentOutOfRangeException"/>
        /// </summary>
        public static ArgumentOutOfRangeExceptionHandler ArgumentOutOfRangeException { get; } = new ArgumentOutOfRangeExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.IndexOutOfRangeException"/>
        /// </summary>
        public static IndexOutOfRangeExceptionHandler IndexOutOfRangeException { get; } = new IndexOutOfRangeExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.InvalidCastException"/>
        /// </summary>
        public static InvalidCastExceptionHandler InvalidCastException { get; } = new InvalidCastExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.InvalidOperationException"/>
        /// </summary>
        public static InvalidOperationExceptionHandler InvalidOperationException { get; } = new InvalidOperationExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.NotSupportedException"/>
        /// </summary>
        public static NotSupportedExceptionHandler NotSupportedException { get; } = new NotSupportedExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.ObjectDisposedException"/>
        /// </summary>
        public static ObjectDisposedExceptionHandler ObjectDisposedException { get; } = new ObjectDisposedExceptionHandler();

        #endregion System

        #region System.IO

#if !(NETSTD10 || NETSTD11)

        /// <summary>
        ///   Handler for <see cref="System.IO.DirectoryNotFoundException"/>
        /// </summary>
        public static DirectoryNotFoundExceptionHandler DirectoryNotFoundException { get; } = new DirectoryNotFoundExceptionHandler();

#endif

        /// <summary>
        ///   Handler for <see cref="System.IO.FileNotFoundException"/>
        /// </summary>
        public static FileNotFoundExceptionHandler FileNotFoundException { get; } = new FileNotFoundExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.IO.InvalidDataException"/>
        /// </summary>
        public static InvalidDataExceptionHandler InvalidDataException { get; } = new InvalidDataExceptionHandler();

        /// <summary>
        ///   Handler for <see cref="System.IO.IOException"/>
        /// </summary>
        public static IOExceptionHandler IOException { get; } = new IOExceptionHandler();

        #endregion System.IO

        #region System.Net

        /// <summary>
        ///   Handler for <see cref="HttpException"/>
        /// </summary>
        public static HttpExceptionHandler HttpException { get; } = new HttpExceptionHandler();

        #endregion System.Net
    }
}

//*** SourceCombiner -> original file RaiseGeneric.cs ***
namespace PommaLabs.KVLite.Thrower
{
    /// <summary>
    ///   Stores items shared by various <see cref="Raise{TEx}"/> instances.
    /// </summary>
    public abstract class RaiseBase
    {
        /// <summary>
        ///   Stores an empty array of <see cref="object"/> used to activate constructors without parameters.
        /// </summary>
        protected static readonly object[] NoCtorParams = new object[0];

        /// <summary>
        ///   Stores an empty array of <see cref="Type"/> used to seek constructors without parameters.
        /// </summary>
        protected static readonly Type[] NoCtorTypes = new Type[0];

        /// <summary>
        ///   Stores the types needed to seek the constructor which takes a string and an exception
        ///   as parameters to instance the exception.
        /// </summary>
        protected static readonly Type[] StrExCtorTypes = { typeof(string), typeof(Exception) };

        /// <summary>
        ///   Stores the type needed to seek the constructor which takes a string as parameter to
        ///   instance the exception.
        /// </summary>
        protected static readonly Type[] StrCtorType = { typeof(string) };
    }

    /// <summary>
    ///   Contains methods that throw specified exception <typeparamref name="TEx"/> if given
    ///   conditions will be verified.
    /// </summary>
    /// <typeparam name="TEx">The type of the exceptions thrown if conditions will be satisfied.</typeparam>
    /// <remarks>
    ///   In order to achieve a good speed, the class caches an instance of the constructors found
    ///   via reflection; therefore, constructors are looked for only once.
    /// </remarks>
    public sealed partial class Raise<TEx> : RaiseBase where TEx : Exception
    {
#pragma warning disable RECS0108 // Warns about static fields in generic types

        /// <summary>
        ///   Stores wheter the exception type is abstract or not. We do this both to provide better
        ///   error messages for the end user and to avoid calling wrong constructors.
        /// </summary>
        private static readonly bool ExTypeIsAbstract = PortableTypeInfo.IsAbstract(typeof(TEx));

        /// <summary>
        ///   Caches an instance of the constructor which takes no arguments. If it does not exist,
        ///   then this field will be null. There must be an instance for each type associated with <see cref="Raise{TEx}"/>.
        /// </summary>
        private static readonly ConstructorInfo NoArgsCtor = GetCtor(NoCtorTypes);

        /// <summary>
        ///   Caches an instance of the constructor which creates an exception with a message. If it
        ///   does not exist, then this field will be null. There must be an instance for each type
        ///   associated with <see cref="Raise{TEx}"/>.
        /// </summary>
        /// <remarks>
        ///   At first, we look for constructors which take a string and an inner exception, because
        ///   some standard exceptions (like ArgumentException or ArgumentNullException) have a
        ///   constructor which takes a string as a "parameter name", not as a message. If a
        ///   constructor with that signature is not found, then we look for a constructor with a
        ///   string as the only argument.
        /// </remarks>
        private static readonly ConstructorInfo MsgCtor = GetCtor(StrExCtorTypes) ?? GetCtor(StrCtorType);

        /// <summary>
        ///   Keeps the number of arguments required by the constructor who creates the exception
        ///   with a message.
        /// </summary>
        private static readonly int MsgArgCount = (MsgCtor == null) ? 0 : MsgCtor.GetParameters().Length;

#pragma warning restore RECS0108 // Warns about static fields in generic types

        /// <summary>
        ///   <see cref="Raise{TEx}"/> must not be instanced.
        /// </summary>
        private Raise()
        {
            throw new InvalidOperationException("This class should not be instantiated");
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TEx"/> if and only if specified
        ///   condition is true.
        /// </summary>
        /// <param name="cond">The condition that determines whether an exception will be thrown.</param>
        /// <exception cref="ThrowerException">
        ///   <typeparamref name="TEx"/> has not a public or internal constructor with no parameters,
        ///   or <typeparamref name="TEx"/> is abstract.
        /// </exception>
        /// <remarks>
        ///   If <paramref name="cond"/> is true, then an exception of type
        ///   <typeparamref name="TEx"/> will be thrown. <br/> In order to do that,
        ///   <typeparamref name="TEx"/> must have a constructor which doesn't take any arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public static void If(bool cond)
        {
            if (cond)
            {
                DoThrow();
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TEx"/> with given message
        ///   <paramref name="message"/> if and only if specified condition is true.
        /// </summary>
        /// <param name="cond">The condition that determines whether an exception will be thrown.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ThrowerException">
        ///   <typeparamref name="TEx"/> has not a public or internal constructor which takes, as
        ///   parameters, either a <see cref="string"/> or a <see cref="string"/> and an
        ///   <see cref="System.Exception"/>. The same exception is thrown when
        ///   <typeparamref name="TEx"/> is abstract.
        /// </exception>
        /// <remarks>
        ///   If <paramref name="cond"/> is true, then an exception of type
        ///   <typeparamref name="TEx"/>, with the message specified by <paramref name="message"/>,
        ///   will be thrown. <br/> In order to do that, <typeparamref name="TEx"/> must have either
        ///   a constructor which takes a <see cref="string"/> and an <see cref="System.Exception"/>
        ///   as arguments, or a constructor which takes a <see cref="string"/> as only parameter.
        ///   <br/> If both constructors are available, then the one which takes a
        ///   <see cref="string"/> and an <see cref="System.Exception"/> will be used to throw the exception.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public static void If(bool cond, string message)
        {
            if (cond)
            {
                DoThrow(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TEx"/> if and only if specified
        ///   condition is true.
        /// </summary>
        /// <param name="cond">The condition that determines whether an exception will be thrown.</param>
        /// <param name="firstParam">
        ///   The first parameter that will be used for the exception constructor, if needed.
        /// </param>
        /// <param name="otherParams">
        ///   Other parameters that will be used for the exception constructor, if needed.
        /// </param>
        /// <exception cref="ThrowerException">
        ///   <typeparamref name="TEx"/> has not a public or internal constructor with specified
        ///   parameters, or <typeparamref name="TEx"/> is abstract.
        /// </exception>
        /// <remarks>
        ///   If <paramref name="cond"/> is true, then an exception of type
        ///   <typeparamref name="TEx"/> will be thrown. <br/> In order to do that,
        ///   <typeparamref name="TEx"/> must have a constructor which takes specified arguments.
        ///   Moreover, each specified argument must not be null, otherwise type inference will fail.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public static void If(bool cond, object firstParam, params object[] otherParams)
        {
            if (cond)
            {
                DoThrow(firstParam, otherParams);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TEx"/> if and only if specified
        ///   condition is false.
        /// </summary>
        /// <param name="cond">The condition that determines whether an exception will be thrown.</param>
        /// <exception cref="ThrowerException">
        ///   <typeparamref name="TEx"/> has not a public or internal constructor with no parameters,
        ///   or <typeparamref name="TEx"/> is abstract.
        /// </exception>
        /// <remarks>
        ///   If <paramref name="cond"/> is false, then an exception of type
        ///   <typeparamref name="TEx"/> will be thrown. <br/> In order to do that,
        ///   <typeparamref name="TEx"/> must have a constructor which doesn't take any arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public static void IfNot(bool cond)
        {
            if (!cond)
            {
                DoThrow();
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TEx"/> with given message
        ///   <paramref name="message"/> if and only if specified condition is false.
        /// </summary>
        /// <param name="cond">The condition that determines whether an exception will be thrown.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ThrowerException">
        ///   <typeparamref name="TEx"/> has not a public or internal constructor which takes, as
        ///   parameters, either a <see cref="string"/> or a <see cref="string"/> and an
        ///   <see cref="System.Exception"/>. The same exception is thrown when
        ///   <typeparamref name="TEx"/> is abstract.
        /// </exception>
        /// <remarks>
        ///   If <paramref name="cond"/> is false, then an exception of type
        ///   <typeparamref name="TEx"/>, with the message specified by <paramref name="message"/>,
        ///   will be thrown. <br/> In order to do that, <typeparamref name="TEx"/> must have either
        ///   a constructor which takes a <see cref="string"/> and an <see cref="System.Exception"/>
        ///   as arguments, or a constructor which takes a <see cref="string"/> as only parameter.
        ///   <br/> If both constructors are available, then the one which takes a
        ///   <see cref="string"/> and an <see cref="System.Exception"/> will be used to throw the exception.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public static void IfNot(bool cond, string message)
        {
            if (!cond)
            {
                DoThrow(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TEx"/> if and only if specified
        ///   condition is false.
        /// </summary>
        /// <param name="cond">The condition that determines whether an exception will be thrown.</param>
        /// <param name="firstParam">
        ///   The first parameter that will be used for the exception constructor, if needed.
        /// </param>
        /// <param name="otherParams">
        ///   Other parameters that will be used for the exception constructor, if needed.
        /// </param>
        /// <exception cref="ThrowerException">
        ///   <typeparamref name="TEx"/> has not a public or internal constructor with specified
        ///   parameters, or <typeparamref name="TEx"/> is abstract.
        /// </exception>
        /// <remarks>
        ///   If <paramref name="cond"/> is false, then an exception of type
        ///   <typeparamref name="TEx"/> will be thrown. <br/> In order to do that,
        ///   <typeparamref name="TEx"/> must have a constructor which takes specified arguments.
        ///   Moreover, each specified argument must not be null, otherwise type inference will fail.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public static void IfNot(bool cond, object firstParam, params object[] otherParams)
        {
            if (!cond)
            {
                DoThrow(firstParam, otherParams);
            }
        }

        #region Private methods

        private static ConstructorInfo GetCtor(IList<Type> ctorTypes)
        {
            return (from c in PortableTypeInfo.GetConstructors(typeof(TEx))
                    let args = c.GetParameters()
                    let zipArgs = MyZip(args, ctorTypes, (argType, ctorType) => new { argType, ctorType })
                    where args.Length == ctorTypes.Count &&
                          (c.IsPublic || c.IsAssembly) &&
                          zipArgs.All(t => ReferenceEquals(t.argType.ParameterType, t.ctorType))
                    select c).FirstOrDefault();
        }

        private static IEnumerable<TResult> MyZip<TFirst, TSecond, TResult>(IEnumerable<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
        {
            Raise.ArgumentNullException.IfIsNull(first, nameof(first));
            Raise.ArgumentNullException.IfIsNull(second, nameof(second));
            Raise.ArgumentNullException.IfIsNull(resultSelector, nameof(resultSelector));
            using (IEnumerator<TFirst> e1 = first.GetEnumerator())
            using (IEnumerator<TSecond> e2 = second.GetEnumerator())
            {
                while (e1.MoveNext() && e2.MoveNext())
                {
#pragma warning disable CC0031 // Check for null before calling a delegate
                    yield return resultSelector(e1.Current, e2.Current);
#pragma warning restore CC0031 // Check for null before calling a delegate
                }
            }
        }

        private static void DoThrow()
        {
            if (ExTypeIsAbstract)
            {
                throw ThrowerException.AbstractEx;
            }
            if (NoArgsCtor == null)
            {
                throw ThrowerException.MissingNoParamsCtorEx;
            }
            throw (TEx) NoArgsCtor.Invoke(NoCtorParams);
        }

        private static void DoThrow(string message)
        {
            if (ExTypeIsAbstract)
            {
                throw ThrowerException.AbstractEx;
            }
            if (MsgCtor == null)
            {
                throw ExTypeIsAbstract ? ThrowerException.AbstractEx : ThrowerException.MissingMsgCtorEx;
            }
            var messageArgs = new object[MsgArgCount];
            messageArgs[0] = message;
            throw (TEx) MsgCtor.Invoke(messageArgs);
        }

        private static void DoThrow(object firstParam, object[] otherParams)
        {
            if (ExTypeIsAbstract)
            {
                throw ThrowerException.AbstractEx;
            }
            if (firstParam == null)
            {
                throw ThrowerException.NullArgEx;
            }
            var paramCount = 1 + otherParams?.Length ?? 0;
            var ctorParams = new object[paramCount];
            ctorParams[0] = firstParam;
            var ctorTypes = new Type[paramCount];
            ctorTypes[0] = firstParam.GetType();
            if (paramCount > 1)
            {
                for (var i = 0; i < otherParams.Length; ++i)
                {
                    var p = otherParams[i];
                    if (p == null)
                    {
                        throw ThrowerException.NullArgEx;
                    }
                    ctorParams[i + 1] = p;
                    ctorTypes[i + 1] = p.GetType();
                }
            }
            var ctor = GetCtor(ctorTypes);
            if (ctor == null)
            {
                DoThrow();
            }
            throw (TEx) ctor.Invoke(ctorParams);
        }

        #endregion Private methods
    }
}

//*** SourceCombiner -> original file ThrowerException.cs ***
namespace PommaLabs.KVLite.Thrower
{
    /// <summary>
    ///   Exception thrown by <see cref="Raise{TEx}"/> when the type parameter passed to that class
    ///   has something invalid (missing constructors, etc).
    /// </summary>
    [Serializable]
    [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
    public sealed class ThrowerException : Exception
    {
        [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
        private ThrowerException(string message)
            : base(message)
        {
        }

        internal static ThrowerException AbstractEx => new ThrowerException("Given exception type is abstract");
        internal static ThrowerException MissingNoParamsCtorEx => new ThrowerException("Given exception type has no parameterless constructor");
        internal static ThrowerException MissingMsgCtorEx => new ThrowerException("Given exception type has not a valid message constructor");
        internal static ThrowerException NullArgEx => new ThrowerException("One of given exception parameters is null, exception constructor inference cannot work");
    }
}

//*** SourceCombiner -> original file ArgumentExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="ArgumentException"/>.
    /// </summary>
    public sealed class ArgumentExceptionHandler
    {
        #region If

        private const string DefaultIfMessage = "Argument is not valid";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <exception cref="ArgumentException">If given condition is true.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition)
        {
            if (condition)
            {
                throw new ArgumentException(DefaultIfMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given condition is true.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName, string message = null)
        {
            if (condition)
            {
                throw new ArgumentException(message ?? DefaultIfMessage, argumentName);
            }
        }

        #endregion If

        #region IfNot

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <exception cref="ArgumentException">If given condition is false.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition)
        {
            if (!condition)
            {
                throw new ArgumentException(DefaultIfMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given condition is false.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName, string message = null)
        {
            if (!condition)
            {
                throw new ArgumentException(message ?? DefaultIfMessage, argumentName);
            }
        }

        #endregion IfNot

        #region IfIsEqualTo

        private const string DefaultIfIsEqualMessage = "Argument is equal to given value";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if <paramref name="argument"/> is equal to <paramref name="comparand"/>.
        /// </summary>
        /// <param name="argument">First argument to be tested for equality.</param>
        /// <param name="comparand">Second argument to be tested for equality.</param>
        /// <exception cref="ArgumentException"><paramref name="argument"/> is equal to <paramref name="comparand"/>.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (Equals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsEqualMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if <paramref name="argument"/> is equal to <paramref name="comparand"/>.
        /// </summary>
        /// <param name="argument">First argument to be tested for equality.</param>
        /// <param name="comparand">Second argument to be tested for equality.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException"><paramref name="argument"/> is equal to <paramref name="comparand"/>.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (Equals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsEqualMessage, argumentName);
            }
        }

        #endregion IfIsEqualTo

        #region IfIsNotEqualTo

        private const string DefaultIfIsNotEqualMessage = "Argument is not equal to given value";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if <paramref name="argument"/> is not equal to <paramref name="comparand"/>.
        /// </summary>
        /// <param name="argument">First argument to be tested for equality.</param>
        /// <param name="comparand">Second argument to be tested for equality.</param>
        /// <exception cref="ArgumentException">
        ///   <paramref name="argument"/> is not equal to <paramref name="comparand"/>.
        /// </exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (!Equals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsNotEqualMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if <paramref name="argument"/> is not equal to <paramref name="comparand"/>.
        /// </summary>
        /// <param name="argument">First argument to be tested for equality.</param>
        /// <param name="comparand">Second argument to be tested for equality.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">
        ///   <paramref name="argument"/> is not equal to <paramref name="comparand"/>.
        /// </exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (!Equals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsNotEqualMessage, argumentName);
            }
        }

        #endregion IfIsNotEqualTo

        #region IfIsSameAs

        private const string DefaultIfIsSameMessage = "Argument is the same object as given value";

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentException"/> if and only if specified
        ///   arguments reference the same object.
        /// </summary>
        /// <param name="argument">First argument to test for reference equality.</param>
        /// <param name="comparand">Second argument to test for reference equality.</param>
        /// <exception cref="ArgumentException">
        ///   <paramref name="argument"/> is the same object as <paramref name="comparand"/>.
        /// </exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsSameMessage);
            }
        }

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentException"/> with given message
        ///   <paramref name="message"/> if and only if specified arguments reference the same object.
        /// </summary>
        /// <param name="argument">First argument to test for reference equality.</param>
        /// <param name="comparand">Second argument to test for reference equality.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ArgumentException">
        ///   <paramref name="argument"/> is the same object as <paramref name="comparand"/>.
        /// </exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsSameMessage, argumentName);
            }
        }

        #endregion IfIsSameAs

        #region IfIsNotSameAs

        private const string DefaultIfIsNotSameMessage = "Argument is not the same object as given value";

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentException"/> if and only if specified
        ///   arguments do not reference the same object.
        /// </summary>
        /// <param name="argument">First argument to test for reference equality.</param>
        /// <param name="comparand">Second argument to test for reference equality.</param>
        /// <exception cref="ArgumentException">
        ///   <paramref name="argument"/> is not the same object as <paramref name="comparand"/>.
        /// </exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (!ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsNotSameMessage);
            }
        }

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentException"/> with given message
        ///   <paramref name="message"/> if and only if specified arguments do not reference the same object.
        /// </summary>
        /// <param name="argument">First argument to test for reference equality.</param>
        /// <param name="comparand">Second argument to test for reference equality.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ArgumentException">
        ///   <paramref name="argument"/> is not the same object as <paramref name="comparand"/>.
        /// </exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (!ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsNotSameMessage, argumentName);
            }
        }

        #endregion IfIsNotSameAs

        #region IfIsNotValid

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given argument is not valid.
        /// </summary>
        /// <typeparam name="TArg">The type of the argument.</typeparam>
        /// <param name="argument">The argument.</param>
        /// <exception cref="ArgumentException">If given argument is not valid.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValid<TArg>(TArg argument)
        {
            IList<ValidationError> validationErrors;
            if (!ObjectValidator.Validate(argument, out validationErrors))
            {
                throw new ArgumentException(ObjectValidator.FormatValidationErrors(validationErrors, null));
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given argument is not valid.
        /// </summary>
        /// <typeparam name="TArg">The type of the argument.</typeparam>
        /// <param name="argument">The argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given argument is not valid.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValid<TArg>(TArg argument, string argumentName, string message = null)
        {
            IList<ValidationError> validationErrors;
            if (!ObjectValidator.Validate(argument, out validationErrors))
            {
                throw new ArgumentException(ObjectValidator.FormatValidationErrors(validationErrors, message), argumentName);
            }
        }

        #endregion IfIsNotValid

        #region IfIsNotValidEnum

        private const string DefaultIfIsNotValidEnumMessage = "Enumeration \"{0}\" is not a valid value for type \"{1}\"";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumeration argument is not defined.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration argument.</typeparam>
        /// <param name="argument">The enumeration argument.</param>
        /// <exception cref="ArgumentException">If given enumeration argument is not defined.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum argument)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumeration argument is not defined.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration argument.</typeparam>
        /// <param name="argument">The enumeration argument.</param>
        /// <param name="argumentName">The name of the enumeration argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given enumeration argument is not defined.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum argument, string argumentName, string message = null)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumeration argument is not defined.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration argument.</typeparam>
        /// <param name="argument">The enumeration argument.</param>
        /// <exception cref="ArgumentException">If given enumeration argument is not defined.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum? argument)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumeration argument is not defined.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration argument.</typeparam>
        /// <param name="argument">The enumeration argument.</param>
        /// <param name="argumentName">The name of the enumeration argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given enumeration argument is not defined.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum? argument, string argumentName, string message = null)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumeration argument is not defined.
        /// </summary>
        /// <param name="enumType">The enumeration type.</param>
        /// <param name="argument">The enumeration argument.</param>
        /// <exception cref="ArgumentException">If given enumeration argument is not defined.</exception>
        /// <remarks>
        ///   This methid is slower than <see cref="IfIsNotValidEnum{TEnum}(TEnum)"/>, please use
        ///   that one if possible.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum(Type enumType, object argument)
        {
            if (!EnumerationValidator.Validate(enumType, argument))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEnumMessage, argument, enumType.Name);
                throw new ArgumentException(exceptionMsg);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumeration argument is not defined.
        /// </summary>
        /// <param name="enumType">The enumeration type.</param>
        /// <param name="argument">The enumeration argument.</param>
        /// <param name="argumentName">The name of the enumeration argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given enumeration argument is not defined.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        ///
        ///   This methid is slower than
        ///   <see cref="IfIsNotValidEnum{TEnum}(TEnum, string, string)"/>, please use that one if possible.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum(Type enumType, object argument, string argumentName, string message = null)
        {
            if (!EnumerationValidator.Validate(enumType, argument))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEnumMessage, argument, enumType.Name);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }

        #endregion IfIsNotValidEnum

        #region IfIsNotValidEmailAddress

        private const string DefaultIfIsNotValidEmailAddressMessage = "String \"{0}\" is not a valid email address";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is not a valid email address.
        /// </summary>
        /// <param name="emailAddress">An email address.</param>
        /// <exception cref="ArgumentException">If given string is not a valid email address.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress)
        {
            if (!EmailAddressValidator.Validate(emailAddress))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is not a valid email address.
        /// </summary>
        /// <param name="emailAddress">An email address.</param>
        /// <param name="validatorOptions">Customizations for the validation process.</param>
        /// <exception cref="ArgumentException">If given string is not a valid email address.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress, EmailAddressValidator.Options validatorOptions)
        {
            if (!EmailAddressValidator.Validate(emailAddress, validatorOptions))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is not a valid email address.
        /// </summary>
        /// <param name="emailAddress">An email address.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given string is not a valid email address.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress, string argumentName, string message = null)
        {
            if (!EmailAddressValidator.Validate(emailAddress))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is not a valid email address.
        /// </summary>
        /// <param name="emailAddress">An email address.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="validatorOptions">Customizations for the validation process.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given string is not a valid email address.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress, string argumentName, EmailAddressValidator.Options validatorOptions, string message = null)
        {
            if (!EmailAddressValidator.Validate(emailAddress, validatorOptions))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }

        #endregion IfIsNotValidEmailAddress

        #region IfIsNotValidPhoneNumber

        private const string DefaultIfIsNotValidPhoneNumberMessage = "String \"{0}\" is not a valid phone number";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is not a valid phone number.
        /// </summary>
        /// <param name="phoneNumber">A phone number.</param>
        /// <exception cref="ArgumentException">If given string is not a valid phone number.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidPhoneNumber(string phoneNumber)
        {
            if (!PhoneNumberValidator.Validate(phoneNumber))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidPhoneNumberMessage, phoneNumber);
                throw new ArgumentException(exceptionMsg);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is not a valid phone number.
        /// </summary>
        /// <param name="phoneNumber">A phone number.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentException">If given string is not a valid phone number.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidPhoneNumber(string phoneNumber, string argumentName, string message = null)
        {
            if (!PhoneNumberValidator.Validate(phoneNumber))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidPhoneNumberMessage, phoneNumber);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }

        #endregion IfIsNotValidPhoneNumber

        #region String validation

        private const string StringIsNullOrEmptyMessage = "Argument cannot be a null or empty string";
        private const string StringIsNullOrWhiteSpaceMessage = "Argument cannot be a null, empty or blank string";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is null or empty.
        /// </summary>
        /// <param name="value">The string value.</param>
        /// <exception cref="ArgumentException">If given string is null or empty.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty(string value)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value))
            {
                throw new ArgumentException(StringIsNullOrEmptyMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is null or empty.
        /// </summary>
        /// <param name="value">The string value.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="ArgumentException">If given string is null or empty.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty(string value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value))
            {
                throw new ArgumentException(message ?? StringIsNullOrEmptyMessage, argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is null, empty or blank.
        /// </summary>
        /// <param name="value">The string value.</param>
        /// <exception cref="ArgumentException">If given string is null, empty or blank.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrWhiteSpace(string value)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value.Trim()))
            {
                throw new ArgumentException(StringIsNullOrWhiteSpaceMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given string is null, empty or blank.
        /// </summary>
        /// <param name="value">The string value.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="ArgumentException">If given string is null, empty or blank.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrWhiteSpace(string value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value.Trim()))
            {
                throw new ArgumentException(message ?? StringIsNullOrWhiteSpaceMessage, argumentName);
            }
        }

        #endregion String validation

        #region Collection and enumerable validation

        internal const string CollectionIsNullOrEmptyMessage = "Argument cannot be a null or empty collection";
        internal const string EnumerableIsNullOrEmptyMessage = "Argument cannot be a null or empty enumerable";

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given collection is null or empty.
        /// </summary>
        /// <typeparam name="TItem">The type of the items contained in the collection.</typeparam>
        /// <param name="value">The collection.</param>
        /// <exception cref="ArgumentException">If given collection is null or empty.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(ICollection<TItem> value)
        {
            if (ReferenceEquals(value, null) || value.Count == 0)
            {
                throw new ArgumentException(CollectionIsNullOrEmptyMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given collection is null or empty.
        /// </summary>
        /// <typeparam name="TItem">The type of the items contained in the collection.</typeparam>
        /// <param name="value">The collection.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="ArgumentException">If given collection is null or empty.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(ICollection<TItem> value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || value.Count == 0)
            {
                throw new ArgumentException(message ?? CollectionIsNullOrEmptyMessage, argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumerable is null or empty.
        /// </summary>
        /// <typeparam name="TItem">The type of the items contained in the enumerable.</typeparam>
        /// <param name="value">The enumerable.</param>
        /// <exception cref="ArgumentException">If given enumerable is null or empty.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(IEnumerable<TItem> value)
        {
            if (ReferenceEquals(value, null) || !value.GetEnumerator().MoveNext())
            {
                throw new ArgumentException(CollectionIsNullOrEmptyMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given enumerable is null or empty.
        /// </summary>
        /// <typeparam name="TItem">The type of the items contained in the enumerable.</typeparam>
        /// <param name="value">The enumerable.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="ArgumentException">If given enumerable is null or empty.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(IEnumerable<TItem> value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || !value.GetEnumerator().MoveNext())
            {
                throw new ArgumentException(message ?? CollectionIsNullOrEmptyMessage, argumentName);
            }
        }

        #endregion Collection and enumerable validation
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file ArgumentNullExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="ArgumentNullException"/>.
    /// </summary>
    public sealed class ArgumentNullExceptionHandler
    {
        private const string DefaultMessage = "Argument, or a nested object, is null";

        #region If(Not)

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <exception cref="ArgumentNullException">If given condition is true.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition)
        {
            if (condition)
            {
                throw new ArgumentNullException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentNullException">If given condition is true.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName, string message = null)
        {
            if (condition)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <exception cref="ArgumentNullException">If given condition is false.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition)
        {
            if (!condition)
            {
                throw new ArgumentNullException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentNullException">If given condition is false.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName, string message = null)
        {
            if (!condition)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }

        #endregion If(Not)

        #region Classes

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given argument if null.
        /// </summary>
        /// <typeparam name="TArg">The type of the argument.</typeparam>
        /// <param name="argument">The argument.</param>
        /// <exception cref="ArgumentNullException">If given argument is null.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg argument)
        {
            if (ReferenceEquals(argument, null))
            {
                throw new ArgumentNullException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given argument if null.
        /// </summary>
        /// <typeparam name="TArg">The type of the argument.</typeparam>
        /// <param name="argument">The argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        /// <exception cref="ArgumentNullException">If given argument is null.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg argument, string argumentName, string message = null)
        {
            if (ReferenceEquals(argument, null))
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }

        #endregion Classes

        #region Nullable structs

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given argument if null.
        /// </summary>
        /// <typeparam name="TArg">The type of the nullable argument.</typeparam>
        /// <param name="argument">The argument.</param>
        /// <exception cref="ArgumentNullException">If given argument has no value.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg? argument)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given argument if null.
        /// </summary>
        /// <typeparam name="TArg">The type of the nullable argument.</typeparam>
        /// <param name="argument">The argument, by reference.</param>
        /// <exception cref="ArgumentNullException">If given argument has no value.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(ref TArg? argument)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given argument if null.
        /// </summary>
        /// <typeparam name="TArg">The type of the nullable argument.</typeparam>
        /// <param name="argument">The argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        /// <exception cref="ArgumentNullException">If given argument has no value.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg? argument, string argumentName, string message = null)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentNullException"/> if given argument if null.
        /// </summary>
        /// <typeparam name="TArg">The type of the nullable argument.</typeparam>
        /// <param name="argument">The argument, by reference.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        /// <exception cref="ArgumentNullException">If given argument has no value.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(ref TArg? argument, string argumentName, string message = null)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }

        #endregion Nullable structs
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file ArgumentOutOfRangeExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="ArgumentOutOfRangeException"/>.
    /// </summary>
    public sealed class ArgumentOutOfRangeExceptionHandler
    {
        #region If

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The optional name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName = null)
        {
            if (condition)
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName, string message)
        {
            if (condition)
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }

        #endregion If

        #region IfNot

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The optional name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName = null)
        {
            if (!condition)
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message.</param>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName, string message)
        {
            if (!condition)
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }

        #endregion IfNot

        #region IfIsNaN

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentOutOfRangeException"/> if and only if
        ///   specified double is <see cref="double.NaN"/>.
        /// </summary>
        /// <param name="number">The double to be tested for <see cref="double.NaN"/> equality.</param>
        /// <param name="argumentName">The optional argument name.</param>
        /// <exception cref="ArgumentOutOfRangeException">Specified double is <see cref="double.NaN"/>.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNaN(double number, string argumentName = null)
        {
            if (double.IsNaN(number))
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentOutOfRangeException"/> if and only if
        ///   specified double is <see cref="double.NaN"/>.
        /// </summary>
        /// <param name="number">The double to be tested for <see cref="double.NaN"/> equality.</param>
        /// <param name="argumentName">The argument name.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ArgumentOutOfRangeException">Specified double is <see cref="double.NaN"/>.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNaN(double number, string argumentName, string message)
        {
            if (double.IsNaN(number))
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }

        #endregion IfIsNaN

        #region IfIsPositiveInfinity

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentOutOfRangeException"/> if and only if
        ///   specified double is <see cref="double.PositiveInfinity"/>.
        /// </summary>
        /// <param name="number">
        ///   The double to be tested for <see cref="double.PositiveInfinity"/> equality.
        /// </param>
        /// <param name="argumentName">The optional argument name.</param>
        /// <exception cref="ArgumentOutOfRangeException">Specified double is <see cref="double.PositiveInfinity"/>.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsPositiveInfinity(double number, string argumentName = null)
        {
            if (double.IsPositiveInfinity(number))
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentOutOfRangeException"/> if and only if
        ///   specified double is <see cref="double.PositiveInfinity"/>.
        /// </summary>
        /// <param name="number">
        ///   The double to be tested for <see cref="double.PositiveInfinity"/> equality.
        /// </param>
        /// <param name="argumentName">The argument name.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ArgumentOutOfRangeException">Specified double is <see cref="double.PositiveInfinity"/>.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsPositiveInfinity(double number, string argumentName, string message)
        {
            if (double.IsPositiveInfinity(number))
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }

        #endregion IfIsPositiveInfinity

        #region IfIsNegativeInfinity

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentOutOfRangeException"/> if and only if
        ///   specified double is <see cref="double.NegativeInfinity"/>.
        /// </summary>
        /// <param name="number">
        ///   The double to be tested for <see cref="double.NegativeInfinity"/> equality.
        /// </param>
        /// <param name="argumentName">The optional argument name.</param>
        /// <exception cref="ArgumentOutOfRangeException">Specified double is <see cref="double.NegativeInfinity"/>.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNegativeInfinity(double number, string argumentName = null)
        {
            if (double.IsNegativeInfinity(number))
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws an exception of type <see cref="ArgumentOutOfRangeException"/> if and only if
        ///   specified double is <see cref="double.NegativeInfinity"/>.
        /// </summary>
        /// <param name="number">
        ///   The double to be tested for <see cref="double.NegativeInfinity"/> equality.
        /// </param>
        /// <param name="argumentName">The argument name.</param>
        /// <param name="message">The message the thrown exception will have.</param>
        /// <exception cref="ArgumentOutOfRangeException">Specified double is <see cref="double.NegativeInfinity"/>.</exception>
        /// <remarks>
        ///   <paramref name="message"/> and <paramref name="argumentName"/> are strictly required arguments.
        /// </remarks>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNegativeInfinity(double number, string argumentName, string message)
        {
            if (double.IsNegativeInfinity(number))
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }

        #endregion IfIsNegativeInfinity

        #region Less - Without parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        #endregion Less - Without parameter name, without message

        #region Less - With parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        #endregion Less - With parameter name, without message

        #region Less - With parameter name, with message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        #endregion Less - With parameter name, with message

        #region LessEqual - Without parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        #endregion LessEqual - Without parameter name, without message

        #region LessEqual - With parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        #endregion LessEqual - With parameter name, without message

        #region LessEqual - With parameter name, with message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   less than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        #endregion LessEqual - With parameter name, with message

        #region Greater - Without parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        #endregion Greater - Without parameter name, without message

        #region Greater - With parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        #endregion Greater - With parameter name, without message

        #region Greater - With parameter name, with message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        #endregion Greater - With parameter name, with message

        #region GreaterEqual - Without parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        #endregion GreaterEqual - Without parameter name, without message

        #region GreaterEqual - With parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        #endregion GreaterEqual - With parameter name, without message

        #region GreaterEqual - With parameter name, with message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        #endregion GreaterEqual - With parameter name, with message

        #region Equal - Without parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        #endregion Equal - Without parameter name, without message

        #region Equal - With parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        #endregion Equal - With parameter name, without message

        #region Equal - With parameter name, with message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        #endregion Equal - With parameter name, with message

        #region NotEqual - Without parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }

        #endregion NotEqual - Without parameter name, without message

        #region NotEqual - With parameter name, without message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }

        #endregion NotEqual - With parameter name, without message

        #region NotEqual - With parameter name, with message

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="ArgumentOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="argumentName">The name of the argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }

        #endregion NotEqual - With parameter name, with message
    }
}

#pragma warning restore CC0091 // Use static method

//*** SourceCombiner -> original file GenericExceptionHandler.cs ***
namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Generic handler used for common exceptions like <see cref="NotSupportedException"/>.
    /// </summary>
    /// <typeparam name="TException">The type of the handled exception.</typeparam>
    public abstract class GenericExceptionHandler<TException>
        where TException : Exception, new()
    {
        #region Abstract members

        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected abstract TException NewWithMessage(string message);

        #endregion Abstract members

        #region If (not)

        /// <summary>
        ///   Throws <typeparamref name="TException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        public void If(bool condition, string message = null)
        {
            if (condition)
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws <typeparamref name="TException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        public void IfNot(bool condition, string message = null)
        {
            if (!condition)
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        #endregion If (not)

        #region Reflection

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if an
        ///   instance of given type can be assigned to specified object.
        /// </summary>
        /// <typeparam name="TType">The type whose instance must be assigned to given object.</typeparam>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsAssignableFrom<TType>(object instance, string message = null)
        {
            if (ReferenceEquals(instance, null) || PortableTypeInfo.IsAssignableFrom(instance, typeof(TType)))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if an
        ///   instance of given type cannot be assigned to specified object.
        /// </summary>
        /// <typeparam name="TType">
        ///   The type whose instance must not be assigned to given object.
        /// </typeparam>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsNotAssignableFrom<TType>(object instance, string message = null)
        {
            if (!PortableTypeInfo.IsAssignableFrom(instance, typeof(TType)))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if an
        ///   instance of given type can be assigned to specified object.
        /// </summary>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="type">The type whose instance must be assigned to given object.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        public void IfIsAssignableFrom(object instance, Type type, string message = null)
        {
            if (PortableTypeInfo.IsAssignableFrom(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if an
        ///   instance of given type cannot be assigned to specified object.
        /// </summary>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="type">The type whose instance must not be assigned to given object.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        public void IfIsNotAssignableFrom(object instance, Type type, string message = null)
        {
            if (ReferenceEquals(instance, null) || !PortableTypeInfo.IsAssignableFrom(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if specified
        ///   object has given type.
        /// </summary>
        /// <typeparam name="TType">The type the object must have.</typeparam>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsInstanceOf<TType>(object instance, string message = null)
        {
            if (instance is TType)
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if specified
        ///   object has not given type.
        /// </summary>
        /// <typeparam name="TType">The type the object must not have.</typeparam>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsNotInstanceOf<TType>(object instance, string message = null)
        {
            if (!(instance is TType))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if specified
        ///   object has given type.
        /// </summary>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="type">The type the object must have.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        public void IfIsInstanceOf(object instance, Type type, string message = null)
        {
            if (PortableTypeInfo.IsInstanceOf(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        /// <summary>
        ///   Throws an exception of type <typeparamref name="TException"/> if and only if specified
        ///   object has not given type.
        /// </summary>
        /// <param name="instance">The object to be tested.</param>
        /// <param name="type">The type the object must not have.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="Exception">
        ///   If given condition is true, an exception of type <typeparamref name="TException"/> is thrown.
        /// </exception>
        public void IfIsNotInstanceOf(object instance, Type type, string message = null)
        {
            if (!PortableTypeInfo.IsInstanceOf(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }

        #endregion Reflection
    }
}

//*** SourceCombiner -> original file IndexOutOfRangeExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="IndexOutOfRangeException"/>.
    /// </summary>
    public sealed class IndexOutOfRangeExceptionHandler
    {
        #region Less - Without message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        #endregion Less - Without message

        #region Less - With message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        #endregion Less - With message

        #region LessEqual - Without message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        #endregion LessEqual - Without message

        #region LessEqual - With message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is less
        ///   than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        #endregion LessEqual - With message

        #region Greater - Without message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        #endregion Greater - Without message

        #region Greater - With message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        #endregion Greater - With message

        #region GreaterEqual - Without message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        #endregion GreaterEqual - Without message

        #region GreaterEqual - With message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is
        ///   greater than or equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        #endregion GreaterEqual - With message

        #region Equal - Without message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is equal
        ///   to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is equal
        ///   to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        #endregion Equal - Without message

        #region Equal - With message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is equal
        ///   to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is equal
        ///   to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        #endregion Equal - With message

        #region NotEqual - Without message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException();
            }
        }

        #endregion NotEqual - Without message

        #region NotEqual - With message

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <typeparam name="TArg">The type of the arguments.</typeparam>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        /// <summary>
        ///   Throws <see cref="IndexOutOfRangeException"/> if <paramref name="argument1"/> is not
        ///   equal to <paramref name="argument2"/>.
        /// </summary>
        /// <param name="argument1">The left side argument.</param>
        /// <param name="argument2">The right side argument.</param>
        /// <param name="message">The message that should be put into the exception.</param>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }

        #endregion NotEqual - With message
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file InvalidCastExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="InvalidCastException"/>.
    /// </summary>
    public sealed class InvalidCastExceptionHandler : GenericExceptionHandler<InvalidCastException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override InvalidCastException NewWithMessage(string message) => new InvalidCastException(message);
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file InvalidOperationExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="InvalidOperationException"/>.
    /// </summary>
    public sealed class InvalidOperationExceptionHandler : GenericExceptionHandler<InvalidOperationException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override InvalidOperationException NewWithMessage(string message) => new InvalidOperationException(message);
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file NotSupportedExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="NotSupportedException"/>.
    /// </summary>
    public sealed class NotSupportedExceptionHandler : GenericExceptionHandler<NotSupportedException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override NotSupportedException NewWithMessage(string message) => new NotSupportedException(message);
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file ObjectDisposedExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers
{
    /// <summary>
    ///   Handler for <see cref="ObjectDisposedException"/>.
    /// </summary>
    public sealed class ObjectDisposedExceptionHandler
    {
        /// <summary>
        ///   Throws <see cref="ObjectDisposedException"/> if the object has been disposed.
        /// </summary>
        /// <param name="disposed">Whether the object has been disposed or not.</param>
        /// <param name="objectName">The required object name.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="ObjectDisposedException">If the object has been disposed.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool disposed, string objectName, string message = null)
        {
            if (disposed)
            {
                throw string.IsNullOrEmpty(message) ? new ObjectDisposedException(objectName) : new ObjectDisposedException(objectName, message);
            }
        }
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file DirectoryNotFoundExceptionHandler.cs ***
#if !(NETSTD10 || NETSTD11)
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers.IO
{
    /// <summary>
    ///   Handler for <see cref="DirectoryNotFoundException"/>.
    /// </summary>
    public sealed class DirectoryNotFoundExceptionHandler : GenericExceptionHandler<DirectoryNotFoundException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override DirectoryNotFoundException NewWithMessage(string message) => new DirectoryNotFoundException(message);

        /// <summary>
        ///   The default message for <see cref="IfNotExists(string, string)"/>, used when none has
        ///   been specified.
        /// </summary>
        public static string DefaultNotExistsMessage { get; } = "Specified directory does not exist";

        /// <summary>
        ///   Throws <see cref="DirectoryNotFoundException"/> if specified directory does not exist.
        /// </summary>
        /// <param name="directoryPath">The path of the directory that should exist.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="FileNotFoundException">If specified directory does not exist.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNotExists(string directoryPath, string message = null)
        {
            if (!Directory.Exists(directoryPath))
            {
                var exMsg = $@"{message ?? DefaultNotExistsMessage} - ""{directoryPath}""";
                throw new DirectoryNotFoundException(exMsg);
            }
        }
    }
}

#pragma warning restore CC0091 // Use static method
#endif
//*** SourceCombiner -> original file FileNotFoundExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers.IO
{
    /// <summary>
    ///   Handler for <see cref="FileNotFoundException"/>.
    /// </summary>
    public sealed class FileNotFoundExceptionHandler : GenericExceptionHandler<FileNotFoundException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override FileNotFoundException NewWithMessage(string message) => new FileNotFoundException(message);

#if !(NETSTD10 || NETSTD11)

        /// <summary>
        ///   The default message for <see cref="IfNotExists(string, string)"/>, used when none has
        ///   been specified.
        /// </summary>
        public static string DefaultNotExistsMessage { get; } = "Specified file does not exist or the caller does not have sufficient permissions to read the specified file";

        /// <summary>
        ///   Throws <see cref="FileNotFoundException"/> if specified file does not exist or the
        ///   caller does not have sufficient permissions to read the specified file.
        /// </summary>
        /// <param name="filePath">The path of the file that should exist.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="FileNotFoundException">
        ///   If specified file does not exist or the caller does not have sufficient permissions to
        ///   read the specified file.
        /// </exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNotExists(string filePath, string message = null)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException(message ?? DefaultNotExistsMessage, filePath);
            }
        }

#endif
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file InvalidDataExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers.IO
{
    /// <summary>
    ///   Handler for <see cref="InvalidDataException"/>.
    /// </summary>
    public sealed class InvalidDataExceptionHandler : GenericExceptionHandler<InvalidDataException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override InvalidDataException NewWithMessage(string message) => new InvalidDataException(message);
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file IOExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers.IO
{
    /// <summary>
    ///   Handler for <see cref="IOException"/>.
    /// </summary>
    public sealed class IOExceptionHandler : GenericExceptionHandler<IOException>
    {
        /// <summary>
        ///   Creates an exception with given message.
        /// </summary>
        /// <param name="message">The message used by the exception.</param>
        /// <returns>An exception with given message.</returns>
        protected override IOException NewWithMessage(string message) => new IOException(message);
    }
}

#pragma warning restore CC0091 // Use static method
//*** SourceCombiner -> original file HttpExceptionHandler.cs ***
#pragma warning disable CC0091 // Use static method

namespace PommaLabs.KVLite.Thrower.ExceptionHandlers.Net
{
    /// <summary>
    ///   Handler for <see cref="HttpException"/>.
    /// </summary>
    public sealed class HttpExceptionHandler
    {
        /// <summary>
        ///   Throws <see cref="HttpException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="httpStatusCode">The HTTP status code corresponding to the error.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="HttpException">If given condition is true.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, HttpStatusCode httpStatusCode, string message = null)
        {
            if (condition)
            {
                throw string.IsNullOrEmpty(message) ? new HttpException(httpStatusCode) : new HttpException(httpStatusCode, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="HttpException"/> if given condition is true.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="httpStatusCode">The HTTP status code corresponding to the error.</param>
        /// <param name="message">The required message.</param>
        /// <param name="additionalInfo">Additional exception info.</param>
        /// <exception cref="HttpException">If given condition is true.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, HttpStatusCode httpStatusCode, string message, HttpExceptionInfo additionalInfo)
        {
            if (condition)
            {
                throw new HttpException(httpStatusCode, message, additionalInfo);
            }
        }

        /// <summary>
        ///   Throws <see cref="HttpException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="httpStatusCode">The HTTP status code corresponding to the error.</param>
        /// <param name="message">The optional message.</param>
        /// <exception cref="HttpException">If given condition is false.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, HttpStatusCode httpStatusCode, string message = null)
        {
            if (!condition)
            {
                throw string.IsNullOrEmpty(message) ? new HttpException(httpStatusCode) : new HttpException(httpStatusCode, message);
            }
        }

        /// <summary>
        ///   Throws <see cref="HttpException"/> if given condition is false.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <param name="httpStatusCode">The HTTP status code corresponding to the error.</param>
        /// <param name="message">The required message.</param>
        /// <param name="additionalInfo">Additional exception info.</param>
        /// <exception cref="HttpException">If given condition is false.</exception>
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, HttpStatusCode httpStatusCode, string message, HttpExceptionInfo additionalInfo)
        {
            if (!condition)
            {
                throw new HttpException(httpStatusCode, message, additionalInfo);
            }
        }
    }
}

#pragma warning restore CC0091 // Use static method

//*** SourceCombiner -> original file EnvironmentExtensions.cs ***
namespace PommaLabs.KVLite.Thrower.Goodies
{
    /// <summary>
    ///   Portable extensions for <see cref="Environment"/>.
    /// </summary>
    public static class EnvironmentExtensions
    {
        private static readonly string[] MapPathStarts = { "~//", "~\\\\", "~/", "~\\", "~" };

        /// <summary>
        ///   Gets a value indicating whether this application is running on ASP.NET.
        /// </summary>
        /// <value><c>true</c> if this application is running on ASP.NET; otherwise, <c>false</c>.</value>
        public static bool AppIsRunningOnAspNet
        {
            get
            {
#if !(NETSTD10 || NETSTD11 || NETSTD13)
                return "web.config".Equals(Path.GetFileName(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile), StringComparison.OrdinalIgnoreCase);
#else
                return false; // .NET Core does not use Web.config, right?
#endif
            }
        }

        /// <summary>
        ///   Maps given path into an absolute one.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>Given path mapped into an absolute one.</returns>
        public static string MapPath(string path)
        {
            Raise.ArgumentNullException.IfIsNull(path, nameof(path));
            if (Path.IsPathRooted(path))
            {
                return path;
            }
            var basePath = GetBaseDirectory();
            var trimmedPath = path.Trim();
            foreach (var start in MapPathStarts)
            {
                if (trimmedPath.StartsWith(start, StringComparison.Ordinal))
                {
                    trimmedPath = trimmedPath.Substring(start.Length, trimmedPath.Length - start.Length);
                    break;
                }
            }
            return Path.Combine(basePath, trimmedPath);
        }

        private static string GetBaseDirectory()
        {
#if (NETSTD10 || NETSTD11)
            return string.Empty;
#elif NETSTD13
            return AppContext.BaseDirectory;
#else
            return AppDomain.CurrentDomain.BaseDirectory;
#endif
        }
    }
}

//*** SourceCombiner -> original file EquatableObject.cs ***
namespace PommaLabs.KVLite.Thrower.Goodies
{
    /// <summary>
    ///   Implements some common <see cref="object"/> methods, like
    ///   <see cref="IEquatable{T}.Equals(T)"/> and <see cref="object.ToString"/>, so that you don't
    ///   have to copy and paste the same boilerplate code.
    /// </summary>
    /// <typeparam name="T">The type of the object inheriting this class.</typeparam>
    [Serializable]
    public abstract class EquatableObject<T> : FormattableObject, IEquatable<T>
        where T : EquatableObject<T>
    {
        /// <summary>
        ///   Seed used to compute hash code.
        /// </summary>
        public const int HashCodeSeed = 397;

        #region Abstract Methods

        /// <summary>
        ///   Returns all property (or field) values that should be used inside
        ///   <see cref="IEquatable{T}.Equals(T)"/> or <see cref="object.GetHashCode"/>.
        /// </summary>
        /// <returns>
        ///   All property (or field) values that should be used inside
        ///   <see cref="IEquatable{T}.Equals(T)"/> or <see cref="object.GetHashCode"/>.
        /// </returns>
        protected abstract IEnumerable<object> GetIdentifyingMembers();

        #endregion Abstract Methods

        #region Object Methods

        /// <summary>
        ///   Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        ///   true if the current object is equal to the <paramref name="other"/> parameter;
        ///   otherwise, false.
        /// </returns>
        public virtual bool Equals(T other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return System.Linq.Enumerable.SequenceEqual(GetIdentifyingMembers(), other.GetIdentifyingMembers());
        }

        /// <summary>
        ///   Determines whether the specified <see cref="System.Object"/>, is equal to this instance.
        /// </summary>
        /// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns>
        ///   <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance;
        ///   otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj.GetType() != GetType()) return false;
            return Equals(obj as T);
        }

        /// <summary>
        ///   Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        ///   A hash code for this instance, suitable for use in hashing algorithms and data
        ///   structures like a hash table.
        /// </returns>
        public override int GetHashCode()
        {
            unchecked
            {
                return System.Linq.Enumerable.Aggregate(GetIdentifyingMembers(), HashCodeSeed, ComputeHashCode);
            }
        }

        #endregion Object Methods

        #region Equality Operators

        /// <summary>
        ///   Implements the operator ==, by checking equality of left and right.
        /// </summary>
        /// <param name="left">The left.</param>
        /// <param name="right">The right.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator ==(EquatableObject<T> left, EquatableObject<T> right) => Equals(left, right);

        /// <summary>
        ///   Implements the operator !=, by checking equality of left and right.
        /// </summary>
        /// <param name="left">The left.</param>
        /// <param name="right">The right.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator !=(EquatableObject<T> left, EquatableObject<T> right) => !Equals(left, right);

        #endregion Equality Operators

        #region Private Methods

        private static int ComputeHashCode(int hashCode, object obj) => (obj == null) ? hashCode : (hashCode ^ obj.GetHashCode());

        #endregion Private Methods
    }
}

//*** SourceCombiner -> original file FormattableObject.cs ***
namespace PommaLabs.KVLite.Thrower.Goodies
{
    /// <summary>
    ///   Implements a simple <see cref="object.ToString"/>, so that you don't have to copy and paste
    ///   the same boilerplate code over and over again.
    /// </summary>
    [Serializable]
    public abstract class FormattableObject
    {
        #region Abstract Methods

        /// <summary>
        ///   Returns all property (or field) values, along with their names, so that they can be
        ///   used to produce a meaningful <see cref="object.ToString"/>.
        /// </summary>
        /// <returns>
        ///   All property (or field) values, along with their names, so that they can be used to
        ///   produce a meaningful <see cref="object.ToString"/>.
        /// </returns>
        protected abstract IEnumerable<KeyValuePair<string, object>> GetFormattingMembers();

        #endregion Abstract Methods

        #region Object Methods

        /// <summary>
        ///   Returns a <see cref="string"/> that represents this instance.
        /// </summary>
        /// <returns>A <see cref="string"/> that represents this instance.</returns>
        public override string ToString() => string.Join(", ", Enumerable.Select(GetFormattingMembers(), ToString).ToArray());

        #endregion Object Methods

        #region Static Methods

        /// <summary>
        ///   Formats given key-value pair in order to use it for <see cref="object.ToString"/>.
        /// </summary>
        /// <param name="pair">Key-value pair.</param>
        /// <returns>Formatted key-value pair.</returns>
        public static string ToString(KeyValuePair<string, object> pair)
        {
            var k = pair.Key;
            var v = pair.Value;
            if (v == null)
            {
                return $"{k}: null";
            }
            var s = v as string;
            if (s != null)
            {
                return $"{k}: \"{s}\"";
            }
            var t = v.GetType();
            if (PortableTypeInfo.IsPrimitive(t))
            {
                return $"{k}: {v}";
            }
            return $"{k}: {{{v}}}";
        }

        #endregion Static Methods
    }
}

//*** SourceCombiner -> original file StringExtensions.cs ***
namespace PommaLabs.KVLite.Thrower.Goodies
{
    /// <summary>
    ///   Extension methods for <see cref="string"/>.
    /// </summary>
    public static class StringExtensions
    {
        #region String manipulation

        /// <summary>
        ///   Returned when there are no substrings.
        /// </summary>
        private static readonly IList<string> NoSubstrings = new string[0];

        /// <summary>
        ///   Truncates given string if its length is greater than specified <paramref name="maxLength"/>.
        /// </summary>
        /// <param name="str">The string to be truncated.</param>
        /// <param name="maxLength">The length at which string should be truncated.</param>
        /// <returns>The first <paramref name="maxLength"/> characters of <paramref name="str"/>.</returns>
        public static string Truncate(this string str, int maxLength)
        {
            if (string.IsNullOrEmpty(str))
            {
                return str;
            }
            maxLength = Math.Max(0, maxLength);
            return (str.Length < maxLength ? str : str.Substring(0, maxLength));
        }

        /// <summary>
        ///   Returns a string array that contains the substrings in this string that are delimited
        ///   by elements of a specified Unicode character array. Substrings are trimmed before being
        ///   returned to the caller.
        /// </summary>
        /// <param name="str">The string that should be split.</param>
        /// <param name="separator">
        ///   An array of Unicode characters that delimit the substrings in this string, an empty
        ///   array that contains no delimiters, or null.
        /// </param>
        /// <returns>
        ///   A string array that contains the substrings in this string that are delimited by
        ///   elements of a specified Unicode character array. Substrings are trimmed before being
        ///   returned to the caller.
        /// </returns>
        public static IList<string> SplitAndTrim(this string str, params char[] separator)
        {
            if (string.IsNullOrEmpty(str))
            {
                return NoSubstrings;
            }
            var split = str.Split(separator, StringSplitOptions.RemoveEmptyEntries);
            if (split.Length == 0)
            {
                return NoSubstrings;
            }
            var result = new string[split.Length];
            for (var i = 0; i < split.Length; ++i)
            {
                result[i] = split[i].Trim();
            }
            return result;
        }

        /// <summary>
        ///   Returns a string array that contains the substrings in this string that are delimited
        ///   by elements of a specified string array. Substrings are trimmed before being returned
        ///   to the caller.
        /// </summary>
        /// <param name="str">The string that should be split.</param>
        /// <param name="separator">
        ///   An array of strings that delimit the substrings in this string, an empty array that
        ///   contains no delimiters, or null.
        /// </param>
        /// <returns>
        ///   A string array that contains the substrings in this string that are delimited by
        ///   elements of a specified string array. Substrings are trimmed before being returned to
        ///   the caller.
        /// </returns>
        public static IList<string> SplitAndTrim(this string str, params string[] separator)
        {
            if (string.IsNullOrEmpty(str))
            {
                return NoSubstrings;
            }
            var split = str.Split(separator, StringSplitOptions.RemoveEmptyEntries);
            if (split.Length == 0)
            {
                return NoSubstrings;
            }
            var result = new string[split.Length];
            for (var i = 0; i < split.Length; ++i)
            {
                result[i] = split[i].Trim();
            }
            return result;
        }

        #endregion String manipulation

        #region Type conversion

        /// <summary>
        ///   Converts given string into the specified enumeration value, applying the specified
        ///   filter on casing.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration.</typeparam>
        /// <param name="enumString">The string value of one enumeration value.</param>
        /// <param name="ignoreCase">Whether to consider casing or not while parsing the string.</param>
        /// <returns>An enumeration value parsed from given string.</returns>
        /// <exception cref="InvalidOperationException">
        ///   Given type parameter <typeparamref name="TEnum"/> is not an enum.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///   Given value cannot be mapped to any enum value.
        /// </exception>
        public static TEnum ToEnum<TEnum>(this string enumString, bool ignoreCase)
            where TEnum : struct
        {
            var enumType = typeof(TEnum);
            Raise.InvalidOperationException.IfNot(PortableTypeInfo.IsEnum(enumType), "Given type is not an enumeration");
#if NET35
            var enumValue = Enum.Parse(enumType, enumString, ignoreCase);
            if (Enum.IsDefined(enumType, enumValue))
            {
                return (TEnum) enumValue;
            }
#else
            TEnum enumValue;
            if (Enum.TryParse(enumString, ignoreCase, out enumValue))
            {
                return enumValue;
            }
#endif
            throw new ArgumentException($"Given value is not available for {enumType.Name}", nameof(enumString));
        }

        /// <summary>
        ///   Converts given string into the specified enumeration value.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration.</typeparam>
        /// <param name="enumString">The string value of one enumeration value.</param>
        /// <returns>An enumeration value parsed from given string.</returns>
        /// <exception cref="InvalidOperationException">
        ///   Given type parameter <typeparamref name="TEnum"/> is not an enum.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///   Given value cannot be mapped to any enum value.
        /// </exception>
        public static TEnum ToEnum<TEnum>(this string enumString) where TEnum : struct => ToEnum<TEnum>(enumString, true);

        /// <summary>
        ///   Converts given string into the specified enumeration value, applying the specified
        ///   filter on casing. If given string cannot be mapped to any enum value, then default
        ///   value for <typeparamref name="TEnum"/> is returned.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration.</typeparam>
        /// <param name="enumString">The string value of one enumeration value.</param>
        /// <param name="ignoreCase">Whether to consider casing or not while parsing the string.</param>
        /// <returns>
        ///   An enumeration value parsed from given string or default enum value if that is not possible.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///   Given type parameter <typeparamref name="TEnum"/> is not an enum.
        /// </exception>
        public static TEnum ToEnumOrDefault<TEnum>(this string enumString, bool ignoreCase)
            where TEnum : struct
        {
            var enumType = typeof(TEnum);
            Raise.InvalidOperationException.IfNot(PortableTypeInfo.IsEnum(enumType), "Given type is not an enumeration");
#if NET35
            var enumValue = Enum.Parse(enumType, enumString, ignoreCase);
            if (Enum.IsDefined(enumType, enumValue))
            {
                return (TEnum) enumValue;
            }
#else
            TEnum enumValue;
            if (Enum.TryParse(enumString, ignoreCase, out enumValue))
            {
                return enumValue;
            }
#endif
            return default(TEnum);
        }

        /// <summary>
        ///   Converts given string into the specified enumeration value. If given string cannot be
        ///   mapped to any enum value, then default value for <typeparamref name="TEnum"/> is returned.
        /// </summary>
        /// <typeparam name="TEnum">The type of the enumeration.</typeparam>
        /// <param name="enumString">The string value of one enumeration value.</param>
        /// <returns>
        ///   An enumeration value parsed from given string or default enum value if that is not possible.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///   Given type parameter <typeparamref name="TEnum"/> is not an enum.
        /// </exception>
        public static TEnum ToEnumOrDefault<TEnum>(this string enumString) where TEnum : struct => ToEnumOrDefault<TEnum>(enumString, true);

        #endregion Type conversion
    }
}

//*** SourceCombiner -> original file PortableSerializationAttributes.cs ***
#if (NETSTD10 || NETSTD11)
namespace System
{
    /// <summary>
    ///   Fake, this is used only to allow serialization on portable platforms.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = false)]
    public sealed class SerializableAttribute : Attribute
    {
    }
    /// <summary>
    ///   Indicates that a field of a serializable class should not be serialized. This class cannot
    ///   be inherited.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false)]
    public sealed class NonSerializedAttribute : Attribute
    {
    }
}
#endif

//*** SourceCombiner -> original file PortableTypeInfo.cs ***
namespace PommaLabs.KVLite.Thrower.Reflection
{
    /// <summary>
    ///   Portable version of some useful reflection methods.
    /// </summary>
    [SecuritySafeCritical]
    public static class PortableTypeInfo
    {
#if !(NETSTD10 || NETSTD11)
        internal const BindingFlags PublicAndPrivateInstanceFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
        internal const BindingFlags PublicInstanceFlags = BindingFlags.Public | BindingFlags.Instance;
#endif
        private static readonly object[] EmptyObjectArray = new object[0];

        /// <summary>
        ///   Represents an empty array of type <see cref="Type"/>. This property is read-only.
        /// </summary>
        public static Type[] EmptyTypes { get; } = new Type[0];

        #region GetTypeAssembly

        /// <summary>
        ///   Returns the assembly to which given type belongs.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The assembly to which given type belongs.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static Assembly GetTypeAssembly(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).Assembly;
#else
            return type.Assembly;
#endif
        }

        /// <summary>
        ///   Returns the assembly to which given type belongs.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>The assembly to which given type belongs.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static Assembly GetTypeAssembly<T>() => GetTypeAssembly(typeof(T));

        #endregion GetTypeAssembly

        /// <summary>
        ///   Gets the custom attributes for given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="inherit">
        ///   True to search this type's inheritance chain to find the attributes; otherwise, false.
        /// </param>
        /// <returns>The custom attributes for given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Attribute> GetCustomAttributes(Type type, bool inherit)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).GetCustomAttributes().ToArray();
#else
            return type.GetCustomAttributes(inherit).Cast<Attribute>().ToArray();
#endif
        }

        /// <summary>
        ///   Gets the custom attributes for given member.
        /// </summary>
        /// <param name="memberInfo">The member.</param>
        /// <param name="inherit">
        ///   True to search this member's inheritance chain to find the attributes; otherwise, false.
        /// </param>
        /// <returns>The custom attributes for given member.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Attribute> GetCustomAttributes(MemberInfo memberInfo, bool inherit)
        {
#if (NETSTD10 || NETSTD11)
            return memberInfo.GetCustomAttributes(inherit).ToArray();
#else
            return memberInfo.GetCustomAttributes(inherit).Cast<Attribute>().ToArray();
#endif
        }

        /// <summary>
        ///   Gets the constructors for given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The constructors for given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<ConstructorInfo> GetConstructors(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).DeclaredConstructors.ToArray();
#else
            return type.GetConstructors(PublicAndPrivateInstanceFlags);
#endif
        }

        /// <summary>
        ///   Gets the constructors for given type.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>The constructors for given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<ConstructorInfo> GetConstructors<T>() => GetConstructors(typeof(T));

        /// <summary>
        ///   Gets the base type of given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The base type of given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static Type GetBaseType(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).BaseType;
#else
            return type.BaseType;
#endif
        }

        /// <summary>
        ///   Gets the generic type definition of given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The generic type definition of given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static Type GetGenericTypeDefinition(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).GetGenericTypeDefinition();
#else
            return type.GetGenericTypeDefinition();
#endif
        }

        /// <summary>
        ///   Gets the generic type arguments of given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The generic type arguments of given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Type> GetGenericTypeArguments(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).GenericTypeArguments;
#else
            return type.GetGenericArguments();
#endif
        }

        /// <summary>
        ///   Gets the interfaces for given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The interfaces for given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Type> GetInterfaces(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).ImplementedInterfaces.ToArray();
#else
            return type.GetInterfaces();
#endif
        }

        /// <summary>
        ///   Gets all the public instance properties for given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The public instance properties for given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<PropertyInfo> GetPublicProperties(Type type)
        {
#if (NETSTD10 || NETSTD11)
            var properties = new List<PropertyInfo>();
            while (type != null)
            {
                var typeInfo = IntrospectionExtensions.GetTypeInfo(type);
                properties.AddRange(typeInfo.DeclaredProperties.Where(p => p.GetMethod.IsPublic));
                type = typeInfo.BaseType;
            }
            return properties;
#else
            return type.GetProperties(PublicInstanceFlags);
#endif
        }

        /// <summary>
        ///   Gets all the instance properties for given type.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>The instance properties for given type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<PropertyInfo> GetPublicProperties<T>() => GetPublicProperties(typeof(T));

        #region GetPublicPropertyValue

        /// <summary>
        ///   Gets the value of given property on given instance.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="propertyName">The property name.</param>
        /// <returns>The value of given property on given instance.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static object GetPublicPropertyValue(object instance, string propertyName)
        {
            Raise.ArgumentNullException.IfIsNull(instance, nameof(instance), "Instance cannot be null");
            Raise.ArgumentException.IfIsNullOrWhiteSpace(propertyName, nameof(propertyName), "Given property cannot be null, empty or blank");
#if !(NETSTD10 || NETSTD11) && FAST_MEMBER
            return FastMember.ObjectAccessor.Create(instance)[propertyName];
#else
            var propertyInfo = GetPublicProperties(instance.GetType()).Single(p => p.Name == propertyName);
            return GetPublicPropertyValue(instance, propertyInfo);
#endif
        }

        /// <summary>
        ///   Gets the value of given property on given instance.
        /// </summary>
        /// <typeparam name="TValue">The type of the property value.</typeparam>
        /// <param name="instance">The instance.</param>
        /// <param name="propertyName">The property name.</param>
        /// <returns>The value of given property on given instance.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static TValue GetPublicPropertyValue<TValue>(object instance, string propertyName) => (TValue) GetPublicPropertyValue(instance, propertyName);

        /// <summary>
        ///   Gets the value of given property on given instance.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="propertyInfo">The property info.</param>
        /// <returns>The value of given property on given instance.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static object GetPublicPropertyValue(object instance, PropertyInfo propertyInfo)
        {
            Raise.ArgumentNullException.IfIsNull(instance, nameof(instance), "Instance cannot be null");
            Raise.ArgumentException.IfNot(propertyInfo.CanRead, nameof(propertyInfo), "Given property cannot be read");
            return propertyInfo.GetValue(instance, EmptyObjectArray);
        }

#if !(NETSTD10 || NETSTD11) && FAST_MEMBER
        /// <summary>
        ///   Gets the value of given property on given instance.
        /// </summary>
        /// <param name="typeAccessor">The type accessor.</param>
        /// <param name="instance">The instance.</param>
        /// <param name="propertyInfo">The property info.</param>
        /// <returns>The value of given property on given instance.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static object GetPublicPropertyValue(FastMember.TypeAccessor typeAccessor, object instance, PropertyInfo propertyInfo)
        {
            Raise.ArgumentNullException.IfIsNull(instance, nameof(instance), "Instance cannot be null");
            Raise.ArgumentException.IfNot(propertyInfo.CanRead, nameof(propertyInfo), "Given property cannot be read");
            return typeAccessor[instance, propertyInfo.Name];
        }
#endif

        #endregion GetPublicPropertyValue

        #region IsAbstract

        /// <summary>
        ///   Determines whether the specified type is abstract.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is abstract.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsAbstract(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsAbstract;
#else
            return type.IsAbstract;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is abstract.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is abstract.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsAbstract<T>() => IsAbstract(typeof(T));

        #endregion IsAbstract

        #region IsClass

        /// <summary>
        ///   Determines whether the specified type is a class.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is a class.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsClass(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsClass;
#else
            return type.IsClass;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is a class.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is a class.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsClass<T>() => IsClass(typeof(T));

        #endregion IsClass

        /// <summary>
        ///   Determines whether an instance of the current <see cref="Type"/> can be assigned from
        ///   an instance of the specified Type.
        /// </summary>
        /// <param name="obj">The object.</param>
        /// <param name="type">The type.</param>
        /// <returns>
        ///   Whether an instance of the current <see cref="Type"/> can be assigned from an instance
        ///   of the specified Type.
        /// </returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsAssignableFrom(object obj, Type type)
        {
            if (ReferenceEquals(obj, null) || ReferenceEquals(type, null))
            {
                return false;
            }
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(obj.GetType()).IsAssignableFrom(IntrospectionExtensions.GetTypeInfo(type));
#else
            return obj.GetType().IsAssignableFrom(type);
#endif
        }

        #region IsEnum

        /// <summary>
        ///   Determines whether the specified type is an enumeration.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is an enumeration.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsEnum(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsEnum;
#else
            return type.IsEnum;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is an enumeration.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is an enumeration.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsEnum<T>() => IsEnum(typeof(T));

        #endregion IsEnum

        #region IsGenericType

        /// <summary>
        ///   Determines whether the specified type is a generic type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is a generic type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericType(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsGenericType;
#else
            return type.IsGenericType;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is a generic type.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is a generic type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericType<T>() => IsGenericType(typeof(T));

        #endregion IsGenericType

        #region IsGenericTypeDefinition

        /// <summary>
        ///   Determines whether the specified type is a generic type definition.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is a generic type definition.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericTypeDefinition(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsGenericTypeDefinition;
#else
            return type.IsGenericTypeDefinition;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is a generic type definition.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is a generic type definition.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericTypeDefinition<T>() => IsGenericTypeDefinition(typeof(T));

        #endregion IsGenericTypeDefinition

        /// <summary>
        ///   Determines whether the specified object is an instance of the current <see cref="Type"/>.
        /// </summary>
        /// <param name="obj">The object.</param>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified object is an instance of the current <see cref="Type"/>.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsInstanceOf(object obj, Type type)
        {
            if (ReferenceEquals(obj, null) || ReferenceEquals(type, null))
            {
                return false;
            }
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).IsAssignableFrom(IntrospectionExtensions.GetTypeInfo(obj.GetType()));
#else
            return type.IsInstanceOfType(obj);
#endif
        }

        #region IsInterface

        /// <summary>
        ///   Determines whether the specified type is an interface.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is an interface.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsInterface(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsInterface;
#else
            return type.IsInterface;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is an interface.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is an interface.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsInterface<T>() => IsInterface(typeof(T));

        #endregion IsInterface

        #region IsPrimitive

        /// <summary>
        ///   Determines whether the specified type is primitive.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is primitive.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPrimitive(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsPrimitive;
#else
            return type.IsPrimitive;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is primitive.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is primitive.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPrimitive<T>() => IsPrimitive(typeof(T));

        #endregion IsPrimitive

        #region IsValueType

        /// <summary>
        ///   Determines whether the specified type is a value type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is a value type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsValueType(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsValueType;
#else
            return type.IsValueType;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is a value type.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is a value type.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsValueType<T>() => IsValueType(typeof(T));

        #endregion IsValueType

        #region IsPublic

        /// <summary>
        ///   Determines whether the specified type is public.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is public.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPublic(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return type.GetTypeInfo().IsPublic;
#else
            return type.IsPublic;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is public.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is public.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPublic<T>() => IsPublic(typeof(T));

        /// <summary>
        ///   Determines whether the specified type is nested public.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>Whether the specified type is nested public.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsNestedPublic(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return type.GetTypeInfo().IsNestedPublic;
#else
            return type.IsNestedPublic;
#endif
        }

        /// <summary>
        ///   Determines whether the specified type is nested public.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>Whether the specified type is nested public.</returns>
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsNestedPublic<T>() => IsNestedPublic(typeof(T));

        #endregion IsPublic

        #region CastTo

        /// <summary>
        ///   Class to cast to type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">Target type.</typeparam>
        /// <remarks>Found on StackOverflow: "http://stackoverflow.com/a/23391746/1880086".</remarks>
        public static class CastTo<T>
        {
            /// <summary>
            ///   Casts <typeparamref name="S"/> to <typeparamref name="T"/>. This does not cause
            ///   boxing for value types. Useful in generic methods.
            /// </summary>
            /// <param name="s">The value that should be cast.</param>
            /// <typeparam name="S">Source type to cast from. Usually a generic type.</typeparam>
            [MethodImpl(Raise.MethodImplOptions)]
            public static T From<S>(S s)
            {
                return Cache<S>.caster(s);
            }

            private static class Cache<S>
            {
                public static readonly Func<S, T> caster = Get();

                private static Func<S, T> Get()
                {
                    var p = Expression.Parameter(typeof(S), "s");
                    var c = Expression.ConvertChecked(p, typeof(T));
                    return Expression.Lambda<Func<S, T>>(c, p).Compile();
                }
            }
        }

        #endregion CastTo
    }
}

//*** SourceCombiner -> original file EmailAddressAttribute.cs ***
#if !NET35

namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   Validates email addresses stored as <see cref="string"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
    public class EmailAddressAttribute : DataTypeAttribute
    {
        /// <summary>
        ///   Default constructor.
        /// </summary>
        public EmailAddressAttribute() : base(DataType.EmailAddress)
        {
            ErrorMessage = "Field '{0}' is not a valid e-mail address.";
        }

        /// <summary>
        ///   Options used by the validation process.
        /// </summary>
        public EmailAddressValidator.Options Options { get; set; }

        /// <summary>
        ///   Validates the email address stored in <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The email address that should be validated.</param>
        /// <param name="validationContext">The validation context.</param>
        /// <returns>True if given email address is valid or null, false otherwise.</returns>
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value == null)
            {
                return ValidationResult.Success;
            }
            var str = value as string;
            if (str != null)
            {
                return EmailAddressValidator.Validate(str, Options)
                    ? ValidationResult.Success
                    : new ValidationResult($"Given string '{str}' is not a valid email address", new[] { validationContext.MemberName });
            }
            return new ValidationResult("Given object is not a valid email address", new[] { validationContext.MemberName });
        }
    }
}

#endif

//*** SourceCombiner -> original file EmailAddressValidator.cs ***
namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   An email address validator.
    /// </summary>
    /// <remarks>An email address validator.</remarks>
    public static class EmailAddressValidator
    {
        private const string AtomCharacters = "!#$%&'*+-/=?^_`{|}~";

        private static bool IsLetterOrDigit(char c)
        {
            return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
        }

        private static bool IsAtom(char c, bool allowInternational)
        {
            return c < 128 ? IsLetterOrDigit(c) || AtomCharacters.IndexOf(c) != -1 : allowInternational;
        }

        private static bool IsDomain(char c, bool allowInternational)
        {
            return c < 128 ? IsLetterOrDigit(c) || c == '-' : allowInternational;
        }

        private static bool SkipAtom(string text, ref int index, bool allowInternational)
        {
            var startIndex = index;
            while (index < text.Length && IsAtom(text[index], allowInternational))
                index++;
            return index > startIndex;
        }

        private static bool SkipSubDomain(string text, ref int index, bool allowInternational)
        {
            var startIndex = index;
            if (!IsDomain(text[index], allowInternational) || text[index] == '-')
                return false;
            index++;
            while (index < text.Length && IsDomain(text[index], allowInternational))
                index++;
            return (index - startIndex) < 64 && text[index - 1] != '-';
        }

        private static bool SkipDomain(string text, ref int index, bool allowInternational, bool allowTopLevelDomains)
        {
            if (!SkipSubDomain(text, ref index, allowInternational))
                return false;
            if (index < text.Length && text[index] == '.')
            {
                do
                {
                    index++;
                    if (index == text.Length)
                        return false;
                    if (!SkipSubDomain(text, ref index, allowInternational))
                        return false;
                } while (index < text.Length && text[index] == '.');
            }
            else if (!allowTopLevelDomains)
            {
                return false;
            }
            return true;
        }

        private static bool SkipQuoted(string text, ref int index, bool allowInternational)
        {
            var escaped = false;
            index++;
            while (index < text.Length)
            {
                if (text[index] >= 128 && !allowInternational)
                    return false;
                if (text[index] == '\\')
                {
                    escaped = !escaped;
                }
                else if (!escaped)
                {
                    if (text[index] == '"')
                        break;
                }
                else
                {
                    escaped = false;
                }
                index++;
            }
            if (index >= text.Length || text[index] != '"')
                return false;
            index++;
            return true;
        }

        private static bool SkipWord(string text, ref int index, bool allowInternational)
        {
            if (text[index] == '"')
                return SkipQuoted(text, ref index, allowInternational);
            return SkipAtom(text, ref index, allowInternational);
        }

        private static bool SkipIPv4Literal(string text, ref int index)
        {
            var groups = 0;
            while (index < text.Length && groups < 4)
            {
                var startIndex = index;
                var value = 0;
                while (index < text.Length && text[index] >= '0' && text[index] <= '9')
                {
                    value = (value * 10) + (text[index] - '0');
                    index++;
                }
                if (index == startIndex || index - startIndex > 3 || value > 255)
                    return false;
                groups++;
                if (groups < 4 && index < text.Length && text[index] == '.')
                    index++;
            }
            return groups == 4;
        }

        private static bool IsHexDigit(char c)
        {
            return (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') || (c >= '0' && c <= '9');
        }

        private static bool SkipIPv6Literal(string text, ref int index)
        {
            var compact = false;
            var colons = 0;
            while (index < text.Length)
            {
                var startIndex = index;
                while (index < text.Length && IsHexDigit(text[index]))
                    index++;
                if (index >= text.Length)
                    break;
                if (index > startIndex && colons > 2 && text[index] == '.')
                {
                    index = startIndex;
                    if (!SkipIPv4Literal(text, ref index))
                        return false;
                    return compact ? colons < 6 : colons == 6;
                }
                var count = index - startIndex;
                if (count > 4)
                    return false;
                if (text[index] != ':')
                    break;
                startIndex = index;
                while (index < text.Length && text[index] == ':')
                    index++;
                count = index - startIndex;
                if (count > 2)
                    return false;
                if (count == 2)
                {
                    if (compact)
                        return false;
                    compact = true;
                    colons += 2;
                }
                else
                {
                    colons++;
                }
            }
            if (colons < 2)
                return false;
            return compact ? colons < 7 : colons == 7;
        }

        /// <summary>
        ///   Validates the specified email address.
        /// </summary>
        /// <remarks>
        ///   <para>Validates the syntax of an email address.</para>
        ///   <para>
        ///     If <paramref name="options"/> contains <see cref="Options.AllowInternational"/>, then
        ///     the validator will use the newer International Email standards for validating the
        ///     email address.
        ///   </para>
        /// </remarks>
        /// <returns><c>true</c> if the email address is valid; otherwise <c>false</c>.</returns>
        /// <param name="emailAddress">An email address.</param>
        /// <param name="options">Customizations for the validation process.</param>
        /// <exception cref="System.ArgumentNullException">
        ///   <paramref name="emailAddress"/> is <c>null</c>.
        /// </exception>
        public static bool Validate(string emailAddress, Options options = Options.None)
        {
            var allowInternational = ((options & Options.AllowInternational) == Options.AllowInternational);
            var allowTopLevelDomains = ((options & Options.AllowTopLevelDomains) == Options.AllowTopLevelDomains);
            var index = 0;
            if (emailAddress == null)
                throw new ArgumentNullException(nameof(emailAddress));
            if (emailAddress.Length == 0 || emailAddress.Length >= 255)
                return false;
            if (!SkipWord(emailAddress, ref index, allowInternational) || index >= emailAddress.Length)
                return false;
            while (emailAddress[index] == '.')
            {
                index++;
                if (index >= emailAddress.Length)
                    return false;
                if (!SkipWord(emailAddress, ref index, allowInternational))
                    return false;
                if (index >= emailAddress.Length)
                    return false;
            }
            if (index + 1 >= emailAddress.Length || index > 64 || emailAddress[index++] != '@')
                return false;
            if (emailAddress[index] != '[')
            {
                if (!SkipDomain(emailAddress, ref index, allowInternational, allowTopLevelDomains))
                    return false;
                return index == emailAddress.Length;
            }
            index++;
            if (index + 8 >= emailAddress.Length)
                return false;
            var ipv6 = emailAddress.Substring(index, 5);
            if (ipv6.ToLowerInvariant() == "ipv6:")
            {
                index += "IPv6:".Length;
                if (!SkipIPv6Literal(emailAddress, ref index))
                    return false;
            }
            else
            {
                if (!SkipIPv4Literal(emailAddress, ref index))
                    return false;
            }
            if (index >= emailAddress.Length || emailAddress[index++] != ']')
                return false;
            return index == emailAddress.Length;
        }

        /// <summary>
        ///   Options used by validation process.
        /// </summary>
        [Flags]
        public enum Options
        {
            /// <summary>
            ///   No option specified.
            /// </summary>
            None = 0,

            /// <summary>
            ///   Whether the validator should allow international characters or not.
            /// </summary>
            AllowInternational = 1,

            /// <summary>
            ///   Whether the validator should allow addresses at top-level domains or not.
            /// </summary>
            AllowTopLevelDomains = 2
        }
    }
}

//*** SourceCombiner -> original file EnumerationAttribute.cs ***
#if !NET35

namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   Validates enumeration-typed members.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
    public class EnumerationAttribute : DataTypeAttribute
    {
        /// <summary>
        ///   Default constructor.
        /// </summary>
        public EnumerationAttribute() : base(DataType.PhoneNumber)
        {
            ErrorMessage = "Field '{0}' has not a valid enumeration value.";
        }

        /// <summary>
        ///   Validates the enumeration stored in <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The enumeration that should be validated.</param>
        /// <param name="validationContext">The validation context.</param>
        /// <returns>True if given enumeration is valid, false otherwise.</returns>
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value != null)
            {
                return EnumerationValidator.Validate(value.GetType(), value)
                    ? ValidationResult.Success
                    : new ValidationResult($"Given value '{value}' is not a valid enumeration value", new[] { validationContext.MemberName });
            }
            return new ValidationResult("Given object is not a valid enumeration value", new[] { validationContext.MemberName });
        }
    }
}

#endif

//*** SourceCombiner -> original file EnumerationValidator.cs ***
namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   An enumeration validator which ensures given enumeration value is defined in specified
    ///   enumeration type. This also works when enumeration has been decorated with <see cref="FlagsAttribute"/>.
    /// </summary>
    public static class EnumerationValidator
    {
        /// <summary>
        ///   Ensures given enumeration value is defined in specified enumeration type.
        /// </summary>
        /// <typeparam name="TEnum">The enumeration type.</typeparam>
        /// <param name="value">The enumeration value.</param>
        /// <returns>
        ///   True if given enumeration value is defined in specified enumeration type, false otherwise.
        /// </returns>
        /// <remarks>This also works when enumeration has been decorated with <see cref="FlagsAttribute"/>.</remarks>
        public static bool Validate<TEnum>(TEnum? value)
            where TEnum : struct
        {
            if (!PortableTypeInfo.IsEnum(CachedEnumValidator<TEnum>.EnumType))
            {
                return false;
            }
            return value.HasValue ? Validate(value.Value) : true;
        }

        /// <summary>
        ///   Ensures given enumeration value is defined in specified enumeration type.
        /// </summary>
        /// <typeparam name="TEnum">The enumeration type.</typeparam>
        /// <param name="value">The enumeration value.</param>
        /// <returns>
        ///   True if given enumeration value is defined in specified enumeration type, false otherwise.
        /// </returns>
        /// <remarks>This also works when enumeration has been decorated with <see cref="FlagsAttribute"/>.</remarks>
        public static bool Validate<TEnum>(TEnum value)
            where TEnum : struct
        {
            if (!PortableTypeInfo.IsEnum(CachedEnumValidator<TEnum>.EnumType))
            {
                return false;
            }
            if (Enum.IsDefined(CachedEnumValidator<TEnum>.EnumType, value))
            {
                return true;
            }
            if (CachedEnumValidator<TEnum>.HasFlagsAttribute)
            {
                var intValue = PortableTypeInfo.CastTo<int>.From(value);
                return (CachedEnumValidator<TEnum>.Mask & intValue) == intValue;
            }
            return false;
        }

        /// <summary>
        ///   Ensures given enumeration value is defined in specified enumeration type.
        /// </summary>
        /// <param name="enumType">The enumeration type.</param>
        /// <param name="value">The enumeration value.</param>
        /// <returns>
        ///   True if given enumeration value is defined in specified enumeration type, false otherwise.
        /// </returns>
        /// <remarks>This also works when enumeration has been decorated with <see cref="FlagsAttribute"/>.</remarks>
        public static bool Validate(Type enumType, object value)
        {
            bool? isReallyAnEnum = null;
            if (PortableTypeInfo.IsGenericType(enumType) && ReferenceEquals(PortableTypeInfo.GetGenericTypeDefinition(enumType), typeof(Nullable<>)))
            {
                var innerEnumType = PortableTypeInfo.GetGenericTypeArguments(enumType)[0];
                isReallyAnEnum = PortableTypeInfo.IsEnum(innerEnumType);
                if (isReallyAnEnum.Value && ReferenceEquals(value, null))
                {
                    return true;
                }
                if (value.GetType() == enumType)
                {
                    if (!PortableTypeInfo.GetPublicPropertyValue<bool>(value, nameof(Nullable<byte>.HasValue)))
                    {
                        return isReallyAnEnum.Value;
                    }
                    value = PortableTypeInfo.GetPublicPropertyValue(value, nameof(Nullable<byte>.Value));
                }
                enumType = innerEnumType;
            }
            if ((isReallyAnEnum.HasValue && !isReallyAnEnum.Value) || !PortableTypeInfo.IsEnum(enumType))
            {
                return false;
            }
            if (Enum.IsDefined(enumType, value))
            {
                return true;
            }
            var hasFlagsAttribute = TypeHasFlagsAttribute(enumType);
            if (hasFlagsAttribute)
            {
                var mask = 0;
                foreach (var enumValue in Enum.GetValues(enumType))
                {
                    mask = mask | (int) enumValue;
                }
                var intValue = (int) value;
                return (mask & intValue) == intValue;
            }
            return false;
        }

        private static bool TypeHasFlagsAttribute(Type enumType) => PortableTypeInfo
             .GetCustomAttributes(enumType, true)
             ?.Any(a => a is FlagsAttribute) ?? false;

        private static class CachedEnumValidator<TEnum>
            where TEnum : struct
        {
            static CachedEnumValidator()
            {
                EnumType = typeof(TEnum);
                HasFlagsAttribute = TypeHasFlagsAttribute(EnumType);
                if (HasFlagsAttribute)
                {
                    var mask = 0;
                    foreach (var enumValue in Enum.GetValues(EnumType))
                    {
                        mask = mask | (int) enumValue;
                    }
                    Mask = mask;
                }
            }

            public static Type EnumType { get; }
            public static bool HasFlagsAttribute { get; }
            public static int Mask { get; }
        }
    }
}

//*** SourceCombiner -> original file ObjectValidator.cs ***
namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   Validates an object public properties that have been decorated with the
    ///   <see cref="ValidateAttribute"/> custom attribute.
    /// </summary>
    public static class ObjectValidator
    {
        /// <summary>
        ///   The placeholder used to indicate the starting object.
        /// </summary>
        public const string RootPlaceholder = "$";

        private static readonly ValidateAttribute DefaultValidation = new ValidateAttribute();

        private static readonly HashSet<Type> AlwaysValidTypes = new HashSet<Type>
        {
            typeof(bool),
            typeof(char),
            typeof(byte),
            typeof(short),
            typeof(ushort),
            typeof(int),
            typeof(uint),
            typeof(long),
            typeof(ulong),
            typeof(float),
            typeof(double),
            typeof(decimal),
            typeof(string)
        };

        /// <summary>
        ///   Prepares a readable messages containing all validation errors.
        /// </summary>
        /// <param name="validationErrors">The validation errors.</param>
        /// <param name="startMessage">An optional prefix.</param>
        /// <returns>A readable messages containing all validation errors.</returns>
        public static string FormatValidationErrors(IEnumerable<ValidationError> validationErrors, string startMessage = null)
        {
            var builder = new StringBuilder();
            if (!string.IsNullOrEmpty(startMessage))
            {
                builder.Append(startMessage);
                builder.Append(" - ");
            }
            builder.AppendLine("Following paths failed the validation checks:");
            foreach (var ve in validationErrors)
            {
                builder.AppendLine($" >> {ve.Path}: {ve.Reason}");
            }
            return builder.ToString();
        }

        /// <summary>
        ///   Validates given object using information contained in the
        ///   <see cref="ValidateAttribute"/> custom attribute.
        /// </summary>
        /// <param name="obj">The object to be validated.</param>
        /// <param name="validationErrors">All validation errors found.</param>
        /// <returns>True if object is valid, false otherwise.</returns>
        public static bool Validate(object obj, out IList<ValidationError> validationErrors)
        {
            validationErrors = new List<ValidationError>();
#if !NET35
            var netValidationErrors = new List<System.ComponentModel.DataAnnotations.ValidationResult>();
#if NET40
            var netValidationContext = new System.ComponentModel.DataAnnotations.ValidationContext(obj, null, null);
#else
            var netValidationContext = new System.ComponentModel.DataAnnotations.ValidationContext(obj);
#endif
            if (!System.ComponentModel.DataAnnotations.Validator.TryValidateObject(obj, netValidationContext, netValidationErrors, true))
            {
                foreach (var netValidationError in netValidationErrors)
                    foreach (var memberName in netValidationError.MemberNames)
                    {
                        validationErrors.Add(new ValidationError
                        {
                            Path = $"{RootPlaceholder}.{memberName}",
                            Reason = netValidationError.ErrorMessage
                        });
                    }
            }
#endif
            return ValidateInternal(obj, RootPlaceholder, DefaultValidation, validationErrors);
        }

        private static bool ValidateInternal(object obj, string path, ValidateAttribute validation, IList<ValidationError> validationErrors)
        {
            if (ReferenceEquals(obj, null))
            {
                if (validation.Required)
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = "Property is required, found null" });
                    return false;
                }
                return true;
            }
            var objType = obj.GetType();
            if (AlwaysValidTypes.Contains(objType) || PortableTypeInfo.IsEnum(objType))
            {
                return true;
            }
            var isValueType = PortableTypeInfo.IsValueType(objType);
            if (validation.Required && isValueType && PortableTypeInfo.IsGenericType(objType) && objType.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                var nullableProps = PortableTypeInfo.GetPublicProperties(objType);
                var nullableHasValueProp = nullableProps.First(p => p.Name == nameof(Nullable<bool>.HasValue));
                if ((bool) PortableTypeInfo.GetPublicPropertyValue(obj, nullableHasValueProp))
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = "Property is required, found null" });
                    return false;
                }
                var nullableValueProp = nullableProps.First(p => p.Name == nameof(Nullable<bool>.Value));
                var nullableValue = PortableTypeInfo.GetPublicPropertyValue(obj, nullableValueProp);
                return ValidateInternal(nullableValue, path, validation, validationErrors);
            }
            var collection = obj as ICollection;
            if (collection != null)
            {
                var c = collection.Count;
                if (c < validation.CollectionItemsMinCount)
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = $"Minimum item count is {validation.CollectionItemsMinCount}, found {c}" });
                }
                if (c > validation.CollectionItemsMaxCount)
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = $"Maximum item count is {validation.CollectionItemsMaxCount}, found {c}" });
                }
            }
            var enumerable = obj as IEnumerable;
            if (enumerable != null && validation.Enumerable)
            {
                var itemValidation = new ValidateAttribute { Required = validation.EnumerableItemsRequired };
                var index = 0;
                foreach (var item in enumerable)
                {
                    var indexedNewPath = $"{path}[{index++}]";
                    ValidateInternal(item, indexedNewPath, itemValidation, validationErrors);
                }
            }
            if (PortableTypeInfo.IsClass(objType) || isValueType)
            {
                var props = PortableTypeInfo.GetPublicProperties(objType);
                var reqProps = from p in props
                               from a in PortableTypeInfo.GetCustomAttributes(p, false)
                               let v = a as ValidateAttribute
                               where v != null
                               select new { PropertyInfo = p, Validation = v };
#if !(NETSTD10 || NETSTD11) && FAST_MEMBER
                var typeAccessor = Reflection.FastMember.TypeAccessor.Create(objType);
#endif
                foreach (var rp in reqProps)
                {
                    var propertyInfo = rp.PropertyInfo;
#if !(NETSTD10 || NETSTD11) && FAST_MEMBER
                    var propertyValue = PortableTypeInfo.GetPublicPropertyValue(typeAccessor, obj, propertyInfo);
#else
                    var propertyValue = PortableTypeInfo.GetPublicPropertyValue(obj, propertyInfo);
#endif
                    var newPath = $"{path}.{propertyInfo.Name}";
                    ValidateInternal(propertyValue, newPath, rp.Validation, validationErrors);
                }
                return validationErrors.Count == 0;
            }
            return true;
        }
    }
}

//*** SourceCombiner -> original file PhoneNumberAttribute.cs ***
#if !NET35

namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   Validates phone numbers stored as <see cref="string"/> members.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
    public class PhoneNumberAttribute : DataTypeAttribute
    {
        /// <summary>
        ///   Default constructor.
        /// </summary>
        public PhoneNumberAttribute() : base(DataType.PhoneNumber)
        {
            ErrorMessage = "Field '{0}' is not a valid phone number.";
        }

        /// <summary>
        ///   Validates the phone number stored in <paramref name="value"/>.
        /// </summary>
        /// <param name="value">The phone number that should be validated.</param>
        /// <param name="validationContext">The validation context.</param>
        /// <returns>True if given phone number is valid or null, false otherwise.</returns>
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value == null)
            {
                return ValidationResult.Success;
            }
            var str = value as string;
            if (str != null)
            {
                return PhoneNumberValidator.Validate(str)
                    ? ValidationResult.Success
                    : new ValidationResult($"Given string '{str}' is not a valid phone number", new[] { validationContext.MemberName });
            }
            return new ValidationResult("Given object is not a valid phone number", new[] { validationContext.MemberName });
        }
    }
}

#endif

//*** SourceCombiner -> original file PhoneNumberValidator.cs ***
namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   A phone number validator.
    /// </summary>
    /// <remarks>A phone number validator.</remarks>
    public static class PhoneNumberValidator
    {
        private static readonly Regex PhoneNumberRegex = CreatePhoneNumberRegex();

        /// <summary>
        ///   Validates the specified phone number.
        /// </summary>
        /// <param name="phoneNumber">A phone number.</param>
        /// <returns><c>true</c> if the phone number is valid; otherwise <c>false</c>.</returns>
        public static bool Validate(string phoneNumber)
        {
            Raise.ArgumentException.IfIsNullOrWhiteSpace(phoneNumber, nameof(phoneNumber));
            return PhoneNumberRegex.IsMatch(phoneNumber);
        }

        private static Regex CreatePhoneNumberRegex()
        {
            const string pattern = @"^(\+\s?)?((?<!\+.*)\(\+?\d+([\s\-\/\.]?\d+)?\)|\d+)([\s\-\/\.]?(\(\d+([\s\-\/\.]?\d+)?\)|\d+))*(\s?(x|ext\.?)\s?\d+)?$";
#if (NETSTD10 || NETSTD11)
            const RegexOptions options = RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture;
#else
            const RegexOptions options = RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture;
#endif
            return new Regex(pattern, options);
        }
    }
}

//*** SourceCombiner -> original file ValidateAttribute.cs ***
namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   Indicates that the property should be validated.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
    public sealed class ValidateAttribute : Attribute
    {
        /// <summary>
        ///   Indicates that the property is required, that is, it will be checked against null.
        ///
        ///   Default value is false.
        /// </summary>
        public bool Required { get; set; } = false;

        /// <summary>
        ///   If the property is an <see cref="IEnumerable"/>, then this flag controls whether it
        ///   should enumerated or not.
        ///
        ///   Default value is true.
        /// </summary>
        public bool Enumerable { get; set; } = true;

        /// <summary>
        ///   If the property is an <see cref="IEnumerable"/>, then this flag controls whether its
        ///   items are required or not.
        ///
        ///   Default value is false.
        /// </summary>
        public bool EnumerableItemsRequired { get; set; } = false;

        /// <summary>
        ///   If the property is an <see cref="ICollection"/>, then this flag controls the minimum
        ///   value for <see cref="ICollection.Count"/>.
        ///
        ///   Default value is
        ///   <code>
        ///     0L
        ///   </code>
        ///   .
        /// </summary>
        public long CollectionItemsMinCount { get; set; } = 0L;

        /// <summary>
        ///   If the property is an <see cref="ICollection"/>, then this flag controls the maximum
        ///   value for <see cref="ICollection.Count"/>.
        ///
        ///   Default value is <see cref="long.MaxValue"/>.
        /// </summary>
        public long CollectionItemsMaxCount { get; set; } = long.MaxValue;
    }
}

//*** SourceCombiner -> original file ValidationError.cs ***
namespace PommaLabs.KVLite.Thrower.Validation
{
    /// <summary>
    ///   Represents an error found while validating an object.
    /// </summary>
    [Serializable]
    public struct ValidationError
    {
        /// <summary>
        ///   The path to the wrong property.
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        ///   What caused the error.
        /// </summary>
        public string Reason { get; set; }
    }
}
